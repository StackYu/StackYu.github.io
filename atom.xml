<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stackyu.github.io</id>
    <title>StackYu</title>
    <updated>2024-10-06T15:26:38.007Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stackyu.github.io"/>
    <link rel="self" href="https://stackyu.github.io/atom.xml"/>
    <subtitle>StackYu的个人博客</subtitle>
    <logo>https://stackyu.github.io/images/avatar.png</logo>
    <icon>https://stackyu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, StackYu</rights>
    <entry>
        <title type="html"><![CDATA[Java枚举]]></title>
        <id>https://stackyu.github.io/post/java-mei-ju/</id>
        <link href="https://stackyu.github.io/post/java-mei-ju/">
        </link>
        <updated>2024-10-06T15:26:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-枚举">1. 枚举</h1>
<p>枚举是一种特殊的数据类型，他是一组预定义的常量，每个常量包括数据和名称。</p>
<blockquote>
<p>枚举无法继承其他类，默认继承Enum类，可以实现其它接口。</p>
<p>枚举常量命名全大写，多单词下划线分割。</p>
</blockquote>
<h1 id="2-创建枚举">2. 创建枚举</h1>
<pre><code class="language-java">public enum Week {
    Monday(&quot;星期一&quot;, &quot;Mon&quot;, 1),
    Tuesday(&quot;星期二&quot;, &quot;Tues&quot;, 2),
    Wednesday(&quot;星期三&quot;, &quot;Wed&quot;, 3),
    Thursday(&quot;星期四&quot;, &quot;Thur&quot;, 4),
    Friday(&quot;星期五&quot;, &quot;Fri&quot;, 5),
    Saturday(&quot;星期六&quot;, &quot;Sat&quot;, 6),
    Sunday(&quot;星期日&quot;, &quot;Sun&quot;, 7);

    // 枚举属性
    private String value;
    private String code;
    private int num;

    // 枚举构造，必须私有
    private Week(String value, String code, int num) {
        this.value = value;
        this.code = code;
        this.num = num;
    }

    public String getValue() {
        return value;
    }

    public String getCode() {
        return code;
    }

    public int getNum() {
        return num;
    }

    // 枚举方法
    public boolean isWeekend() {
        return this == Saturday || this == Sunday;
    }
}
</code></pre>
<pre><code class="language-java">// 需要实现接口
interface Printable {
    void print();
}

// 实现接口
public enum Week implements Printable {
    Monday(&quot;星期一&quot;, &quot;Mon&quot;, 1), Tuesday(&quot;星期二&quot;, &quot;Tues&quot;, 2), Wednesday(&quot;星期三&quot;, &quot;Wed&quot;, 3), Thursday(&quot;星期四&quot;, &quot;Thur&quot;, 4), Friday(&quot;星期五&quot;, &quot;Fri&quot;, 5), Saturday(&quot;星期六&quot;, &quot;Sat&quot;, 6), Sunday(&quot;星期日&quot;, &quot;Sun&quot;, 7);

    // 枚举属性
    private String value;
    private String code;
    private int num;

    // 枚举构造，必须私有
    private Week(String value, String code, int num) {
        this.value = value;
        this.code = code;
        this.num = num;
    }

    public String getValue() {
        return value;
    }

    public String getCode() {
        return code;
    }

    public int getNum() {
        return num;
    }

    // 枚举方法
    public boolean isWeekend() {
        return this == Saturday || this == Sunday;
    }

    @Override
    public void print() {
        System.out.println(&quot;Today is &quot; + this.value);
    }
}
</code></pre>
<h1 id="3-枚举使用">3. 枚举使用</h1>
<pre><code class="language-java">public static void main(String[] args) {
    // 访问枚举常量
    Week monday = Week.Monday;
    // 访问枚举常量属性
    System.out.println(monday.getValue());
    System.out.println(Week.Monday.getValue());
    // 访问枚举方法
    System.out.println(monday.isWeekend());
    System.out.println(Week.Monday.isWeekend());
    Week.Sunday.print();
}
</code></pre>
<h1 id="4-枚举默认方法">4. 枚举默认方法</h1>
<p><code>values()</code>:获得所有枚举常量数组。</p>
<pre><code class="language-java">public static void main(String[] args) {
    Week[] values = Week.values();
    for (Week value : values) {
        System.out.println(value);
    }
}

// Monday
// Tuesday
// Wednesday
// Thursday
// Friday
// Saturday
// Sunday
</code></pre>
<p><code>valueOf(String)</code>:通过字符串，获得对应枚举常量。</p>
<pre><code class="language-java">public static void main(String[] args) {
    Week sunday = Week.valueOf(&quot;Sunday&quot;);
    System.out.println(sunday.getValue());
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java异常]]></title>
        <id>https://stackyu.github.io/post/java-yi-chang/</id>
        <link href="https://stackyu.github.io/post/java-yi-chang/">
        </link>
        <updated>2024-10-06T14:11:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-异常">1. 异常</h1>
<p>Java中异常父类为Throwable，子类为Error和Exception。</p>
<p>Exception：这是通常说的异常父类，子类主要分为RuntimeException和其他异常。出现后可处理。</p>
<p>Error：主要是虚拟机错误或者线程错误等，程序终结者。出现程序终结。</p>
<h1 id="2-exception">2. Exception</h1>
<ul>
<li>编译时异常（也称受查异常）</li>
<li>运行时异常（也称非受查异常(Unchecked Exception)）（RunTimeException以及其子类对应的异常，都称为运行时异常，比如上述的数组越界，空指针，算数异常等等）</li>
</ul>
<h1 id="3-异常处理">3. 异常处理</h1>
<h2 id="31-异常抛出和捕获">3.1 异常抛出和捕获</h2>
<p>异常抛出：<code>throw new 异常类(&quot;异常原因&quot;);</code></p>
<pre><code class="language-java">// 捕获异常
public class ExceptionTest {
    public static void main(String[] args) {
        try {
            // 可能出现异常代码
        } catch (Exception e) {
            // 匹配出现的代码
            // 出现匹配代码后进行处理
        } finally {
            // 始终会执行代码，常用于
        }
    }
}
</code></pre>
<p><strong><em>PS：<br>
catch匹配异常可以出现多个。<br>
catch匹配多个时，父类异常在后(父亲兜底)</em></strong></p>
<h2 id="32-异常声明">3.2 异常声明</h2>
<blockquote>
<p>当前方法存在异常，但是不进行处理，通过异常声明，提醒调用者进行处理。</p>
</blockquote>
<p>异常声明：</p>
<pre><code class="language-java">public String testMethod(String str) throws NullPointerException {
    // ...
}
</code></pre>
<h1 id="4-自定义异常">4. 自定义异常</h1>
<p>创建类继承Exception或RuntimeException即可。继承前者表示为检测异常，编写代码时必须进行处理。继承后者为运行时异常，无需提前处理。</p>
<pre><code class="language-java">// 示例
public class IOException extends Exception {
    static final long serialVersionUID = 7818375828146090155L;

    public IOException() {
        super();
    }

    public IOException(String message) {
        super(message);
    }

    public IOException(String message, Throwable cause) {
        super(message, cause);
    }


    public IOException(Throwable cause) {
        super(cause);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker基础]]></title>
        <id>https://stackyu.github.io/post/docker-ji-chu/</id>
        <link href="https://stackyu.github.io/post/docker-ji-chu/">
        </link>
        <updated>2023-01-31T01:25:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-docker概述">1. Docker概述</h1>
<blockquote>
<p>Docker是一个开源应用容器引擎，它可以将应用和依赖一起打包到可移植容器中，然后发布到任何linux或windows系统上运行，</p>
</blockquote>
<h2 id="11-如何解决不同应用依赖兼容问题">1.1 如何解决不同应用依赖兼容问题</h2>
<blockquote>
<p>Docker将应用、依赖、函数库和配置一起打包，形成可运行镜像。Docker应用运行在容器中，采用沙箱机制，相互隔离就不存在依赖兼容问题。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker0.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="12-docker和虚拟机区别">1.2 Docker和虚拟机区别</h2>
<ul>
<li>Docker是系统的一个进程，模仿系统运行的环境，环境之间是相互隔离的。虚拟机模仿设备硬件，然后在模拟硬件上运行其他操作系统。</li>
<li>docker体积小，运行快，性能好。虚拟机体积大，运行慢，性能一般。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker1.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="13-镜像和容器">1.3 镜像和容器</h2>
<p>镜像：应用及依赖打成的包称为镜像。</p>
<p>容器：通过镜像创建的运行程序被称为容器，一个镜像可以创建多个容器，之间相互隔离。</p>
<p>镜像分为两部分：<code>repository:tag</code>，在没有指定版本情况下默认是latest。</p>
<figure data-type="image" tabindex="3"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker2.png?raw=true" alt="" loading="lazy"></figure>
<h1 id="2-基本操作">2. 基本操作</h1>
<figure data-type="image" tabindex="4"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker4.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="21-pull">2.1 pull</h2>
<blockquote>
<p>从远程仓库拉取镜像。</p>
</blockquote>
<p><code>docker pull [镜像名称][:镜像版本]</code></p>
<p>示例：<code>docker pull mysql:8.0</code></p>
<h2 id="22-images">2.2 images</h2>
<blockquote>
<p>查看所有镜像</p>
</blockquote>
<p><code>docker images</code></p>
<h2 id="23-save-load">2.3 save、load</h2>
<blockquote>
<p>将镜像导出到本地，或者从本地导入镜像。</p>
</blockquote>
<p><code>docker save -o [保存的目标文件名称] [镜像名称]</code></p>
<p>示例：<code>docker save -o nginx.tar nginx:latest</code></p>
<p>加载示例：<code>docker load -i nginx.tar</code></p>
<h2 id="24-rmi">2.4 rmi</h2>
<blockquote>
<p>删除镜像</p>
</blockquote>
<p>删除nginx镜像：<code>docker rmi nginx:latest</code></p>
<h1 id="3-容器操作">3. 容器操作</h1>
<figure data-type="image" tabindex="5"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker5.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="31-run">3.1 run</h2>
<blockquote>
<p>创建并运行一个容器，处于运行状态。</p>
</blockquote>
<p><code>docker run --name containerName -p 80:80 -d nginx</code></p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>--name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx</li>
</ul>
<h2 id="32-exec">3.2 exec</h2>
<blockquote>
<p>进入容器进行操作，例如修改配置文件等。</p>
</blockquote>
<p><code>docker exec -it mn bash</code></p>
<ul>
<li>docker exec ：进入容器内部，执行一个命令</li>
<li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li>
<li>mn ：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
<h2 id="33-pause-unpause">3.3 pause、unpause</h2>
<blockquote>
<p>pause：让一个运行的容器暂停, unpause：让一个容器从暂停状态恢复运行。</p>
</blockquote>
<p>暂停：<code>docker pause 容器名称</code></p>
<p>暂停恢复：<code>docker unpause 容器名称</code></p>
<h2 id="34-stop-start-restart">3.4 stop、start、restart</h2>
<p>stop:<code>docker stop 容器名称</code>，停止一个容器。</p>
<p>start:<code>docker start 容器名称</code>，开始运行一个容器。</p>
<p>restart:<code>docker restart 容器名称</code>，重启一个容器。</p>
<h2 id="35-rm">3.5 rm</h2>
<blockquote>
<p>删除一个容器。</p>
</blockquote>
<p><code>docker rm [选项] [容器0，容器1...]</code></p>
<p>强制删除：<code>docker rm -f [容器0，容器1...]</code></p>
<p>删除连接网络：<code>docker rm -l [网络连接名]</code></p>
<p>删除容器，并删除容器挂载的数据卷：<code>docker rm -v [容器0，容器1...]</code></p>
<h1 id="4-数据卷操作">4. 数据卷操作</h1>
<blockquote>
<p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。不同系统可能存在差异（宿主系统）。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker3.png?raw=true" alt="" loading="lazy"></figure>
<h2 id="41-操作命令">4.1 操作命令</h2>
<p>语法：<code>docker volume [COMMAND]</code></p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h2 id="42-挂载数据卷">4.2 挂载数据卷</h2>
<pre><code class="language-shell">docker run \
--name mn \
-v html:/usr/share/nginx/html \
-p 80:80 \
-d nginx
</code></pre>
<p><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</p>
<h1 id="5-dockerfile自定义镜像">5. Dockerfile自定义镜像</h1>
<blockquote>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker7.png?raw=true" alt="" loading="lazy"></figure>
<p>示例：<br>
<img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker6.png?raw=true" alt="" loading="lazy"></p>
<blockquote>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
</blockquote>
<pre><code class="language-shell"># 指定基础镜像
FROM ubuntu:16.04
# 配置环境变量，JDK的安装目录
ENV JAVA_DIR=/usr/local

# 拷贝jdk和java项目的包
COPY ./jdk8.tar.gz $JAVA_DIR/
COPY ./docker-demo.jar /tmp/app.jar

# 安装JDK
RUN cd $JAVA_DIR \
 &amp;&amp; tar -xf ./jdk8.tar.gz \
 &amp;&amp; mv ./jdk1.8.0_144 ./java8

# 配置环境变量
ENV JAVA_HOME=$JAVA_DIR/java8
ENV PATH=$PATH:$JAVA_HOME/bin

# 暴露端口
EXPOSE 8090
# 入口，java项目的启动命令
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
<p>执行构建命令即可：<code>docker build -t javaweb:1.0 .</code></p>
<blockquote>
<p>以上是比较麻烦的，也可以基于已经有的jdk环境进行配置，就比较简单。</p>
</blockquote>
<pre><code class="language-shell">FROM java:8-alpine
COPY ./app.jar /tmp/app.jar
EXPOSE 8090
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
<h1 id="6-docker-compose">6. Docker-Compose</h1>
<blockquote>
<p>Docker Compose就是一个文本文件，而无需手动一个个创建和运行容器！Compose就是一个文本文件。</p>
</blockquote>
<p>语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">官网</a></p>
<p>创建Compose文件：</p>
<pre><code class="language-yaml">version: &quot;3.2&quot;

services:
  nacos:
    image: nacos/nacos-server
    environment:
      MODE: standalone
    ports:
      - &quot;8848:8848&quot;
  mysql:
    image: mysql:5.7.25
    environment:
      MYSQL_ROOT_PASSWORD: 123
    volumes:
      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;
      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;
  mallUser:
    build: ./mall-user
  mallOrder:
    build: ./mall-user
  mallGateway:
    build: ./mall-gateway
    ports:
      - &quot;10010:10010&quot;
</code></pre>
<ul>
<li><code>nacos</code>：作为注册中心和配置中心
<ul>
<li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li>
<li><code>environment</code>：环境变量
<ul>
<li><code>MODE: standalone</code>：单点模式启动</li>
</ul>
</li>
<li><code>ports</code>：端口映射，这里暴露了8848端口</li>
</ul>
</li>
<li><code>mysql</code>：数据库
<ul>
<li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li>
<li><code>environment</code>：环境变量
<ul>
<li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li>
</ul>
</li>
<li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li>
</ul>
</li>
<li><code>mall-user</code>、<code>mall-order</code>、<code>mall-gateway</code>：都是基于Dockerfile临时构建的</li>
</ul>
<p>新建文件目录：</p>
<figure data-type="image" tabindex="8"><img src="https://github.com/xiaoyu2017/JavaOffer/blob/master/img/docker8.png?raw=true" alt="" loading="lazy"></figure>
<blockquote>
<p>mysql目录是用于挂载目录。</p>
</blockquote>
<p>三个服务项目目录下的Dockerfile配置：</p>
<pre><code class="language-text">FROM java:8-alpine
COPY ./app.jar /tmp/app.jar
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
<p>修改服务配置文件，微服务容器之间访问使用的是容器名称访问：</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://mysql:33060/mall?useSSL=false
    username: root
    password: root
    driver-class-name: com.mysql.jdbc.Driver
  application:
    name: mall-user
  cloud:dock
  nacos:
    server-addr: nacos:8848 # nacos服务地址
</code></pre>
<p>使用maven打包服务：</p>
<pre><code class="language-xml">
&lt;build&gt;
    &lt;!-- 服务打包的最终名称 --&gt;
    &lt;finalName&gt;app&lt;/finalName&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>在当前目录执行构建命令：<code>docker-compose up -d</code></p>
<h1 id="8-安装docker">8. 安装Docker</h1>
<h2 id="81-centos7安装">8.1 Centos7安装</h2>
<p>卸载老版本：</p>
<pre><code class="language-shell">yum remove docker \
  docker-client \
  docker-client-latest \
  docker-common \
  docker-latest \
  docker-latest-logrotate \
  docker-logrotate \
  docker-selinux \
  docker-engine-selinux \
  docker-engine \
  docker-ce
</code></pre>
<p>安装yum：系统需要联网</p>
<pre><code class="language-shell">yum install -y yum-utils \
           device-mapper-persistent-data \
           lvm2 --skip-broken
</code></pre>
<p>设置镜像源：</p>
<pre><code class="language-shell"># 设置docker镜像源
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
sed -i 's/download.docker.com/mirrors.aliyun.com\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo

yum makecache fast
</code></pre>
<p>安装docker-ce：社区免费版</p>
<pre><code class="language-shell">yum install -y docker-ce
</code></pre>
<p>docker需要使用各种端口，所以建议使用时关闭防火墙：</p>
<pre><code class="language-shell"># 关闭
systemctl stop firewalld
# 禁止开机启动防火墙
systemctl disable firewalld
</code></pre>
<p>docker的操作命令：</p>
<pre><code class="language-shell">systemctl start docker  # 启动docker服务

systemctl stop docker  # 停止docker服务

systemctl restart docker  # 重启docker服务
</code></pre>
<p>配置阿里镜像：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors?accounttraceid=cb36295bddcd4367b89d118e2471c930hdty">阿里镜像配置</a></p>
<h2 id="82-centos7安装dockercompose">8.2 Centos7安装DockerCompose</h2>
<p>下载安装包：</p>
<pre><code class="language-shell"># 安装
curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>
<pre><code class="language-shell"># 修改权限
chmod +x /usr/local/bin/docker-compose
</code></pre>
<pre><code class="language-shell"># 补全命令
curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose
</code></pre>
<p>如果有错误：<code>echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</code></p>
<h1 id="7-搭建docker镜像私库">7. 搭建Docker镜像私库</h1>
<h2 id="71-简化版私有仓库">7.1 简化版私有仓库</h2>
<blockquote>
<p>由Docker官网提供的简易仓库管理镜像，功能完善，但是不具备操作化界面。</p>
</blockquote>
<pre><code class="language-shell">docker run -d \
    --restart=always \
    --name registry	\
    -p 5000:5000 \
    -v registry-data:/var/lib/registry \
    registry
</code></pre>
<h2 id="72-图形界面仓库">7.2 图形界面仓库</h2>
<blockquote>
<p>使用DockerCompose部署界面化仓库</p>
</blockquote>
<pre><code class="language-yaml">version: '3.0'
services:
  registry:
    image: registry
    volumes:
      - ./registry-data:/var/lib/registry
  ui:
    image: joxit/docker-registry-ui:static
    ports:
      - 8080:80
    environment:
      - REGISTRY_TITLE=我的私有仓库
      - REGISTRY_URL=http://registry:5000
    depends_on:
      - registry
</code></pre>
<p>配置信任地址：</p>
<pre><code class="language-shell"># 打开要修改的文件
vi /etc/docker/daemon.json
# 添加内容：
&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]
# 重加载
systemctl daemon-reload
# 重启docker
systemctl restart docker
</code></pre>
<h1 id="9-镜像推送拉取">9. 镜像推送拉取</h1>
<p>重新tag本地镜像：<code>docker tag nginx:latest 本地仓库名称:端口/nginx:1.0 </code></p>
<p>推送镜像：<code>docker push 本地仓库名称:端口/nginx:1.0 </code></p>
<p>拉取镜像：<code>docker pull 本地仓库名称:端口/nginx:1.0 </code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MybatisPlus基础]]></title>
        <id>https://stackyu.github.io/post/mybatisplus-ji-chu/</id>
        <link href="https://stackyu.github.io/post/mybatisplus-ji-chu/">
        </link>
        <updated>2023-01-24T17:55:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-入门案例">1. 入门案例</h1>
<blockquote>
<p>MybatisPlus是对Mybatis进行简化，通过简单的配置就能进行简单CRUD。</p>
</blockquote>
<p>1.添加依赖</p>
<pre><code class="language-xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>Mapper接口继承BaseMapper</li>
</ol>
<pre><code class="language-java">// 需要添加注解被Spring容器管理，不添加此注解就需要在启动类上添加@MapperScan(&quot;xxx.x..&quot;)
@Mapper
public interface UserDao extends BaseMapper&lt;User&gt; {

    @Select(&quot;select * from user&quot;)
    List&lt;User&gt; selectAll();
}
</code></pre>
<blockquote>
<p>如果未发现表，那就需要在实体类上添加@TableName注解</p>
</blockquote>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    private Long id;
    private String name;
    private Integer age;
    private String email;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date birthday;

    // get set toString
}
</code></pre>
<p>3.测试</p>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void contextLoads() {
        System.out.println(userDao.selectAll());
        System.out.println(userDao.selectById(1617790416520863746L));
    }
}
</code></pre>
<h2 id="11-简单crud">1.1 简单CRUD</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void contextSave() {
        User user = new User();
        user.setName(&quot;yh&quot;);
        user.setAge(18);
        user.setEmail(&quot;yh@email.com&quot;);
        user.setBirthday(new Date());
        System.out.println(userDao.insert(user));
        System.out.println(user);
    }

    @Test
    void contextDelete() {
        System.out.println(userDao.deleteById(1617790566173523969L));
    }

    @Test
    void contextUpdate() {
        User user = new User();
        user.setId(1617790416520863746L);
        user.setName(&quot;yh&quot;);
        user.setAge(3);
        user.setEmail(&quot;yh@email.com&quot;);
        System.out.println(userDao.updateById(user));
        System.out.println(user);
    }

    @Test
    void contextSelect() {
        System.out.println(userDao.selectAll());
        System.out.println(userDao.selectById(1617790416520863746L));
    }

}
</code></pre>
<h1 id="2-分页">2. 分页</h1>
<ol>
<li>设置拦截器</li>
</ol>
<pre><code class="language-java">
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        //1 创建MybatisPlusInterceptor拦截器对象
        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();
        //2 添加分页拦截器
        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mpInterceptor;
    }
}
</code></pre>
<ol start="2">
<li>分页查询</li>
</ol>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    //分页查询
    @Test
    void testSelectPage() {
        //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数
        IPage&lt;User&gt; page = new Page&lt;&gt;(1, 3);
        //2 执行分页查询
        userDao.selectPage(page, null);
        //3 获取分页结果
        System.out.println(&quot;当前页码值：&quot; + page.getCurrent());
        System.out.println(&quot;每页显示数：&quot; + page.getSize());
        System.out.println(&quot;一共多少页：&quot; + page.getPages());
        System.out.println(&quot;一共多少条数据：&quot; + page.getTotal());
        System.out.println(&quot;数据：&quot; + page.getRecords());
    }
}
</code></pre>
<h1 id="3-dql操作">3. DQL操作</h1>
<h2 id="31-根据单条件查询">3.1 根据单条件查询</h2>
<blockquote>
<p>使用Wrapper实现类QueryWrapper和LambdaQueryWrapper进行查询。<code>lt()</code>方法类似<code>&lt;</code></p>
</blockquote>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testSelect() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.lt(&quot;age&quot;, 18);
        List&lt;User&gt; users = userDao.selectList(wrapper);
        System.out.println(&quot;数据：&quot; + users);
    }

    @Test
    void testSelectLambda() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.lambda().lt(User::getAge, 18);
        List&lt;User&gt; users = userDao.selectList(wrapper);
        System.out.println(&quot;数据：&quot; + users);
    }

    @Test
    void testSelectLambda1() {
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
        wrapper.lt(User::getAge, 18);
        List&lt;User&gt; users = userDao.selectList(wrapper);
        System.out.println(&quot;数据：&quot; + users);
    }
}
</code></pre>
<h2 id="32-多条件查询">3.2 多条件查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    // 多条件
    @Test
    void testSelectLambda2() {
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
        wrapper.lt(User::getAge, 18);
        wrapper.gt(User::getAge, 1);

        // 支持链式编程
        // wrapper.lt(User::getAge, 18).gt(User::getAge, 1);
        List&lt;User&gt; users = userDao.selectList(wrapper);
        System.out.println(&quot;数据：&quot; + users);
    }

    // 多条件
    @Test
    void testSelectLambda3() {
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
        // 支持链式编程，默认是and，可以使用or()
        wrapper.lt(User::getAge, 18).or().gt(User::getAge, 1);
        List&lt;User&gt; users = userDao.selectList(wrapper);
        System.out.println(&quot;数据：&quot; + users);
    }
}
</code></pre>
<blockquote>
<p>多条件之间默认是and，也可以通过<code>or()</code>方法实现or。</p>
</blockquote>
<h2 id="33-null判断">3.3 null判断</h2>
<blockquote>
<p>在多个查询条件中可能存在没有输入的条件，这时就需要大量的<code>if</code>判断，MP对此进行了简化。</p>
</blockquote>
<blockquote>
<p>接收页面条件时不能再用实体类，例如查询年龄范围肯定会传入两个值，这时实体类就没法存储。这时就需要创建vo</p>
</blockquote>
<pre><code class="language-java">
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class UserQuery extends User {

    private Integer age2;
}
</code></pre>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    // 多条件
    @Test
    void testSelect1() {
        //模拟页面传递过来的查询数据
        UserQuery uq = new UserQuery();
        uq.setAge(10);
        uq.setAge2(30);

        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
        // 只有当第一个条件为true后，查询才会成立进行查询
        lqw.lt(null != uq.getAge2(), User::getAge, uq.getAge2());
        lqw.gt(null != uq.getAge(), User::getAge, uq.getAge());
        List&lt;User&gt; userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
</code></pre>
<h2 id="34-查询投影">3.4 查询投影</h2>
<blockquote>
<p>MP默认查询表所有，如果只查询想要列可以通过方法来控制的。</p>
</blockquote>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
        lqw.select(User::getId, User::getName, User::getAge);
        List&lt;User&gt; userList = userDao.selectList(lqw);
        System.out.println(userList);
    }

    @Test
    void testGetAll() {
        QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();
        // QueryWrapper需要手动编写列名
        lqw.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;tel&quot;);
        List&lt;User&gt; userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
</code></pre>
<h2 id="35-聚合查询">3.5 聚合查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();
        // lqw.select(&quot;count(*) as count&quot;); 
        // SELECT count(*) as count FROM user

        // lqw.select(&quot;max(age) as maxAge&quot;); 
        // SELECT max(age) as maxAge FROM user 

        // lqw.select(&quot;min(age) as minAge&quot;);
        // SELECT min(age) as minAge FROM user

        // lqw.select(&quot;sum(age) as sumAge&quot;); 
        // SELECT sum(age) as sumAge FROM user

        lqw.select(&quot;avg(age) as avgAge&quot;);
        // SELECT avg(age) as avgAge FROM user 
        List&lt;Map&lt;String, Object&gt;&gt; userList = userDao.selectMaps(lqw);
        System.out.println(userList);
    }
}
</code></pre>
<h2 id="36-分组查询">3.6 分组查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();
        lqw.select(&quot;count(*) as count,tel&quot;);
        lqw.groupBy(&quot;tel&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectMaps(lqw);
        System.out.println(list);
    }
}
</code></pre>
<h2 id="37-等值查询">3.7 等值查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
        lqw.eq(User::getName, &quot;Jerry&quot;).eq(User::getPassword, &quot;jerry&quot;);
        User loginUser = userDao.selectOne(lqw);
        System.out.println(loginUser);
    }
}
</code></pre>
<blockquote>
<ul>
<li>selectList：查询结果为多个或者单个</li>
<li>selectOne:查询结果为单个</li>
</ul>
</blockquote>
<h2 id="38-范围查询">3.8 范围查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
        lqw.between(User::getAge, 10, 30);
        // SELECT id,name,password,age,tel FROM user WHERE (age BETWEEN ? AND ?) 
        List&lt;User&gt; userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
</code></pre>
<blockquote>
<ul>
<li>gt():大于(&gt;)</li>
<li>ge():大于等于(&gt;=)</li>
<li>lt():小于(&lt;)</li>
<li>lte():小于等于(&lt;=)</li>
<li>between():between ? and ?</li>
</ul>
</blockquote>
<h2 id="39-模糊查询">3.9 模糊查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();
        lqw.likeLeft(User::getName, &quot;J&quot;);
        //SELECT id,name,password,age,tel FROM user WHERE (name LIKE ?) 
        List&lt;User&gt; userList = userDao.selectList(lqw);
        System.out.println(userList);
    }
}
</code></pre>
<h2 id="310-排序查询">3.10 排序查询</h2>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testGetAll() {
        LambdaQueryWrapper&lt;User&gt; lwq = new LambdaQueryWrapper&lt;&gt;();
        /*
         * condition ：条件，返回boolean， 当condition为true，进行排序，如果为false，则不排序
         * isAsc:是否为升序，true为升序，false为降序
         * columns：需要操作的列
         */
        lwq.orderBy(true, false, User::getId);
        userDao.selectList(lw);
    }
}
</code></pre>
<ul>
<li>orderBy排序
<ul>
<li>condition:条件，true则添加排序，false则不添加排序</li>
<li>isAsc:是否为升序，true升序，false降序</li>
<li>columns:排序字段，可以有多个</li>
</ul>
</li>
<li>orderByAsc/Desc(单个column):按照指定字段进行升序/降序</li>
<li>orderByAsc/Desc(多个column):按照多个字段进行升序/降序</li>
<li>orderByAsc/Desc
<ul>
<li>condition:条件，true添加排序，false不添加排序</li>
<li>多个columns：按照多个字段进行排序</li>
</ul>
</li>
</ul>
<h1 id="4-映射兼容问题">4. 映射兼容问题</h1>
<h2 id="41-列名与属性名可不同">4.1 列名与属性名可不同</h2>
<blockquote>
<p>使用<code>@TableField</code>注解表明与哪个表列名映射</p>
</blockquote>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    private Long id;

    @TableField(&quot;user_name&quot;)
    private String name;

    private Integer age;

    private String email;

    private Date birthday;

}
</code></pre>
<h2 id="42-表中未定义属性">4.2 表中未定义属性</h2>
<blockquote>
<p>有时并不是所有属性都是在表中定义的，例如多表查询时，实体类中一般定义的不是对象Id而是对象，这时就可以通过@TableField注解的exist属性完成。</p>
</blockquote>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    private Long id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;

    @TableField(exist = false)
    private Role role;
}
</code></pre>
<h2 id="43-限制列表查询权限">4.3 限制列表查询权限</h2>
<blockquote>
<p>铭感列一般是不需要查询返回的，这时就需要限制列表查询。可以通过@TableField注解的select属性完成。</p>
</blockquote>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    private Long id;
    private String name;
    @TableField(select = false)
    private String password;
    private Integer age;
    private String email;
    private Date birthday;
}
</code></pre>
<h2 id="44-表名不同步">4.4 表名不同步</h2>
<pre><code class="language-java">// 显示设置表名
@TableName(&quot;user&quot;)
public class User {

    private Long id;
    private String name;
    @TableField(select = false)
    private String password;
    private Integer age;
    private String email;
    private Date birthday;
}
</code></pre>
<h1 id="5-dml">5. DML</h1>
<h2 id="51-id策略">5.1 Id策略</h2>
<blockquote>
<p>针对不同的业务需求，Id的生成策略也是不同的。MP主要提供了以下一些策略。</p>
</blockquote>
<ul>
<li>NONE（默认）: 不设置id生成策略，MP自动生成</li>
<li>AUTO: 使用数据库自增</li>
<li>INPUT:用户手工输入id</li>
<li>ASSIGN_ID:雪花算法生成id(可兼容数值型与字符串型)</li>
<li>ASSIGN_UUID:以UUID生成算法作为id生成策略</li>
</ul>
<h3 id="511-auto">5.1.1 AUTO</h3>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;

}
</code></pre>
<h3 id="512-input">5.1.2 INPUT</h3>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    @TableId(value = &quot;id&quot;, type = IdType.INPUT)
    private Long id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;

}
</code></pre>
<blockquote>
<p>需要手动输入Id，如果未设置id将抛出异常。</p>
</blockquote>
<h3 id="513-assign_id">5.1.3 ASSIGN_ID</h3>
<blockquote>
<p>雪花算法相关查看</p>
</blockquote>
<p><a href="../../Distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md#11-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95">雪花算法</a></p>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_ID)
    private Long id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;

}
</code></pre>
<h3 id="514-assign_uuid">5.1.4 ASSIGN_UUID</h3>
<blockquote>
<p>使用此策略需要将主键类型改为字符串，同样数据库也是，长度不能小于32位。</p>
</blockquote>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_UUID)
    private String id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;

}
</code></pre>
<h2 id="52-批量操作">5.2 批量操作</h2>
<h3 id="521-批量删除">5.2.1 批量删除</h3>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testDelete() {
        List&lt;Long&gt; list = new ArrayList&lt;&gt;();
        list.add(1402551342481838081L);
        list.add(1402553134049501186L);
        list.add(1402553619611430913L);
        // 批量删除
        userDao.deleteBatchIds(list);
    }
}
</code></pre>
<h3 id="522-批量查询">5.2.2 批量查询</h3>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void testDelete() {
        List&lt;Long&gt; list = new ArrayList&lt;&gt;();
        list.add(1L);
        list.add(3L);
        list.add(4L);
        // 批量查询
        userDao.selectBatchIds(list);
    }
}
</code></pre>
<h2 id="53-逻辑删除">5.3 逻辑删除</h2>
<blockquote>
<p>一些数据在删除过程中，并不是真正的直接删除掉，而是通过设置字段的值来标记其处于删除状态。所以删除其实就是修改。</p>
</blockquote>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_UUID)
    private String id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;
    @TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;)
    //value为正常数据的值，delval为删除数据的值
    private Integer deleted;

}
</code></pre>
<blockquote>
<p>既然是逻辑删除，那查询是否受影响了，显然MP已经帮我们处理了。</p>
</blockquote>
<h2 id="54-乐观锁">5.4 乐观锁</h2>
<blockquote>
<p>通过添加version字段来实现乐观锁，MP通过<code>@Version</code>注解简化这一操作。</p>
</blockquote>
<ol>
<li>添加注解</li>
</ol>
<pre><code class="language-java">
@TableName(&quot;user&quot;)
public class User {

    @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_UUID)
    private String id;
    private String name;
    private Integer age;
    private String email;
    private Date birthday;
    @TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;)
    //value为正常数据的值，delval为删除数据的值
    private Integer deleted;

    @Version
    private Integer version;

}
</code></pre>
<ol start="2">
<li>设置拦截器</li>
</ol>
<pre><code class="language-java">
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        // 创建MybatisPlusInterceptor拦截器对象
        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();

        // 添加分页拦截器
        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());

        // 添加乐观锁拦截器
        mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return mpInterceptor;
    }

}
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<blockquote>
<p>要想实现乐观锁，首先第一步应该是拿到表中的version，然后拿version当条件在将version加1更新回到数据库表中，所以我们在查询的时候，需要对其进行查询</p>
</blockquote>
<pre><code class="language-java">
@SpringBootTest
class Mybatisplus03DqlApplicationTests {
    @Autowired
    private UserDao userDao;

    @Test
    void
    testUpdate() {
        User user = new User();
        user.setId(3L);
        user.setName(&quot;Jock666&quot;);
        user.setVersion(1);
        userDao.updateById(user);
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="../../img/mp0.png" alt="" loading="lazy"></figure>
<blockquote>
<p>从sql语句可以看出，MP会把version+1更新到表中，但是在条件中对比的还是未+1的version。</p>
<p>所以更新带有乐观锁的数据步骤是先查询再更新，需要带上version属性，不然乐观锁会失效。</p>
<p>version值不相等，更新返回行数会为0。</p>
</blockquote>
<h1 id="6-逆向工程">6. 逆向工程</h1>
<blockquote>
<p>依照数据库的字段自动生成实体类和Mapper</p>
</blockquote>
<ol>
<li>依赖</li>
</ol>
<blockquote>
<p>SpringBoot版本使用<code>2.5.1</code>其他版本可能会出现问题。</p>
</blockquote>
<pre><code class="language-xml">
&lt;dependencies&gt;
    &lt;!--spring webmvc--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!--mybatisplus--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;3.4.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--druid--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.1.16&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--mysql--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!--test--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!--lombok--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.12&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--代码生成器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
        &lt;version&gt;3.4.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--velocity模板引擎--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
        &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>编写生成类</li>
</ol>
<pre><code class="language-java">public class CodeGenerator {
    public static void main(String[] args) {
        //1.获取代码生成器的对象
        AutoGenerator autoGenerator = new AutoGenerator();

        //设置数据库相关配置
        DataSourceConfig dataSource = new DataSourceConfig();
        dataSource.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://localhost:33060/BookManager?serverTimezone=UTC&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;root&quot;);
        autoGenerator.setDataSource(dataSource);

        //设置全局配置
        GlobalConfig globalConfig = new GlobalConfig();
        globalConfig.setOutputDir(System.getProperty(&quot;user.dir&quot;) + &quot;/SpringBoot2/src/main/java&quot;);    //设置代码生成位置
        globalConfig.setOpen(false);    //设置生成完毕后是否打开生成代码所在的目录
        globalConfig.setAuthor(&quot;xiaoyu&quot;);    //设置作者
        globalConfig.setFileOverride(true);     //设置是否覆盖原始生成的文件
        globalConfig.setMapperName(&quot;%sDao&quot;);    //设置数据层接口名，%s为占位符，指代模块名称
        globalConfig.setIdType(IdType.ASSIGN_ID);   //设置Id生成策略
        autoGenerator.setGlobalConfig(globalConfig);

        //设置包名相关配置
        PackageConfig packageInfo = new PackageConfig();
        packageInfo.setParent(&quot;com.aaa&quot;);   //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径
        packageInfo.setEntity(&quot;domain&quot;);    //设置实体类包名
        packageInfo.setMapper(&quot;dao&quot;);   //设置数据层包名
        autoGenerator.setPackageInfo(packageInfo);

        //策略设置
        StrategyConfig strategyConfig = new StrategyConfig();
//        strategyConfig.setInclude(&quot;tbl_user&quot;);  //设置当前参与生成的表名，参数为可变参数
//        strategyConfig.setTablePrefix(&quot;tbl_&quot;);  //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_
        strategyConfig.setRestControllerStyle(true);    //设置是否启用Rest风格
        strategyConfig.setVersionFieldName(&quot;version&quot;);  //设置乐观锁字段名
        strategyConfig.setLogicDeleteFieldName(&quot;deleted&quot;);  //设置逻辑删除字段名
        strategyConfig.setEntityLombokModel(true);  //设置是否启用lombok
        autoGenerator.setStrategy(strategyConfig);
        //2.执行生成操作
        autoGenerator.execute();
    }
}

</code></pre>
<blockquote>
<p>直接运行以上代码即可。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot基础]]></title>
        <id>https://stackyu.github.io/post/springboot-ji-chu/</id>
        <link href="https://stackyu.github.io/post/springboot-ji-chu/">
        </link>
        <updated>2023-01-23T16:03:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-springboot">1. SpringBoot</h1>
<blockquote>
<p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。</p>
</blockquote>
<h2 id="11-入门案例">1.1 入门案例</h2>
<ol>
<li>新建工程，如下：</li>
</ol>
<figure data-type="image" tabindex="1"><img src="../../../img/springboot0.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="../../../img/springboot1.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>等待依赖加载，直接运行启动类即可：</li>
</ol>
<pre><code class="language-java">
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<p><strong>通过以上步骤就直接运行一个Web项目了，什么都不用配，简直逆天。</strong></p>
<p>项目自动创建后生成的东西：</p>
<pre><code class="language-java">// SpringBoot注解
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<pre><code class="language-xml">
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;!--继承--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.8&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;

    &lt;groupId&gt;cn.fishland&lt;/groupId&gt;
    &lt;artifactId&gt;SpringBoot&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--继承依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--继承依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;!--SpringBootMaven插件--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>官网创建项目：</p>
<p><a href="https://spring.io/projects/spring-boot">SpringBoot</a></p>
<figure data-type="image" tabindex="3"><img src="../../../img/springboot2.png" alt="" loading="lazy"></figure>
<h2 id="12-切换jetty服务器">1.2 切换Jetty服务器</h2>
<p>修改配置：</p>
<pre><code class="language-xml">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;exclusions&gt;
            &lt;!--排除默认tomcat服务器--&gt;
            &lt;exclusion&gt;
                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;

    &lt;!--添加jetty服务器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h1 id="2-配置文件">2. 配置文件</h1>
<blockquote>
<p>SpringBoot配置文件支持三种，分别为properties、yml和yaml三种。但是名称都是application不能变。</p>
</blockquote>
<h2 id="21-三种配置优先级">2.1 三种配置优先级</h2>
<blockquote>
<p><code>properties &gt; yml &gt; yaml</code></p>
</blockquote>
<p>yml和yaml语法规则：</p>
<ul>
<li>大小写敏感</li>
<li>属性层级关系使用多行描述，每行结尾使用冒号结束</li>
<li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）空格的个数并不重要，只要保证同层级的左侧对齐即可。</li>
<li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li>
<li><code>#</code>表示注释</li>
</ul>
<pre><code class="language-yaml">enterprise:
  name: itcast
  age: 16
  tel: 4006184000
  subject:
    - Java
    - 前端
    - 大数据
</code></pre>
<h2 id="22-读取yml配置">2.2 读取yml配置</h2>
<ol>
<li>@Value读取</li>
</ol>
<pre><code class="language-yaml">fish:
  info: springboot
</code></pre>
<pre><code class="language-java">
@Controller
public class HomeController {

    @Value(&quot;${fish.info}&quot;)
    private String fishInfo;

    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test(String name) {
        System.out.println(&quot;name=&quot; + name);
        System.out.println(&quot;fishInfo=&quot; + fishInfo);
        return &quot;Hello SpringBoot!&quot;;
    }
}
</code></pre>
<ol start="2">
<li>注入Environment读取</li>
</ol>
<pre><code class="language-yaml">less:
  data: fish
</code></pre>
<pre><code class="language-java">
@Controller
public class HomeController {

    @Autowired
    private Environment env;

    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test(String name) {
        System.out.println(&quot;name=&quot; + name);
        System.out.println(&quot;Environment lessData=&quot; + env.getProperty(&quot;less.data&quot;));
        return &quot;Hello SpringBoot!&quot;;
    }
}
</code></pre>
<ol start="3">
<li>自定义类</li>
</ol>
<pre><code class="language-yaml">enterprise:
  name: itcast
  age: 16
  tel: 4006184000
  subject:
    - Java
    - 前端
    - 大数据
</code></pre>
<pre><code class="language-java">
@Component
@ConfigurationProperties(prefix = &quot;enterprise&quot;)
public class Enterprise {
    private String name;
    private int age;
    private String tel;
    private String[] subject;

    public Enterprise() {
    }

    // get set toString ...
}

@Controller
public class HomeController {

    @Autowired
    private Enterprise enterprise;

    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test(String name) {
        System.out.println(&quot;name=&quot; + name);
        System.out.println(&quot;enterprise=&quot; + enterprise);
        return &quot;Hello SpringBoot!&quot;;
    }
}
</code></pre>
<h2 id="23-多环境配置">2.3 多环境配置</h2>
<blockquote>
<p>面对不同环境，配置文件是不相同。但是不能每次切换环境就修改配置文件，这样比较繁琐。SpringBoot支持多环境配置。</p>
</blockquote>
<h3 id="231-yml多环境">2.3.1 yml多环境</h3>
<blockquote>
<p>yml在同一个文件中使用<code>---</code>分割多环境配置</p>
</blockquote>
<pre><code class="language-yaml">#设置启用的环境
spring:
  profiles:
    active: dev #表示使用的是开发环境的配置

---

#开发
spring:
  profiles: dev #给开发环境起的名字
server:
  port: 80

---

#生产
spring:
  profiles: pro #给开发环境起的名字
server:
  port: 81

---

#测试
spring:
  profiles: test #给开发环境起的名字
server:
  port: 82

</code></pre>
<p>较新版本启用环境配置可能是下面的：</p>
<pre><code class="language-yaml">#开发
spring:
  config:
    activate:
      on-profile: dev
</code></pre>
<h3 id="232-peoperties多环境">2.3.2 peoperties多环境</h3>
<blockquote>
<p>properties是分开在不同配置文件中的</p>
</blockquote>
<p>application.properties</p>
<pre><code class="language-properties">spring.profiles.active=test
</code></pre>
<p>application-dev.properties</p>
<pre><code class="language-properties">server.port=80
</code></pre>
<p>application-pro.properties</p>
<pre><code class="language-properties">server.port=81
</code></pre>
<p>application-test.properties</p>
<pre><code class="language-properties">server.port=82
</code></pre>
<h3 id="233-命令行配置">2.3.3 命令行配置</h3>
<blockquote>
<p>SpringBoot项目打包成jar直接可以使用<code>java -jar xxx.jar</code>运行，也可以添加参数</p>
</blockquote>
<p>修改端口：<code>java -jar xxx.jar --server.port=88 --spring.profiles.active=test</code></p>
<h3 id="234-配置文件优先级">2.3.4 配置文件优先级</h3>
<ul>
<li>1级：classpath：application.yml</li>
<li>2级：classpath：config/application.yml</li>
<li>3级：jar包同目录下 ：application.yml</li>
<li>4级：jar包同目录下 ：config/application.yml</li>
</ul>
<p>优先级：<strong>4级&gt;3级&gt;2级&gt;1级</strong></p>
<h1 id="3-整合junit">3. 整合Junit</h1>
<blockquote>
<p>以下配合需要测试类和项目启动类都在相同包路径，否则就需要在<code>@SpringBootTest</code>中添加启动类<code>@SpringBootTest(classes = Application.class)</code></p>
</blockquote>
<ol>
<li>导入Junit依赖</li>
<li>编写测试类</li>
</ol>
<pre><code class="language-java">// 添加此注解即可
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserService userService;

    @Test
    void contextLoads() {
        System.out.println(userService);
    }

}
</code></pre>
<h1 id="4-整合mybatis">4. 整合Mybatis</h1>
<h2 id="41-整合mybatis示例">4.1 整合Mybatis示例</h2>
<ol>
<li>添加依赖</li>
</ol>
<pre><code class="language-xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-xml">
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.30&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2.添加数据源配置</p>
<pre><code class="language-yaml">server:
  port: 80
spring:
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:33060/SSM?serverTimezone=UTC
    username: root
    password: root

</code></pre>
<ol start="3">
<li>编写Mapper</li>
</ol>
<blockquote>
<p>mapper被扫描到有两种，1.在接口类上加<code>@Mapper</code>注解，2.在启动类上加<code>@MapperScan(&quot;cn.xxx.xxx&quot;)</code>注解</p>
</blockquote>
<pre><code class="language-java">// 让Spring扫描到
@Mapper
public interface UserDao {

    @Select(&quot;select * from user&quot;)
    List&lt;User&gt; selectAll();
}
</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void contextLoads() {
        System.out.println(userDao.selectAll());
    }

}
</code></pre>
<h2 id="42-使用druid数据源">4.2 使用Druid数据源</h2>
<ol>
<li>添加依赖</li>
</ol>
<pre><code class="language-xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.15&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>添加配置</li>
</ol>
<pre><code class="language-yaml">server:
  port: 80
spring:
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:33060/SSM?serverTimezone=UTC
    username: root
    password: root
    type: com.alibaba.druid.pool.DruidDataSource # 指定数据库连接池
</code></pre>
<ol start="3">
<li>测试：看日志辨别连接池</li>
</ol>
<pre><code class="language-java">
@SpringBootTest
class ApplicationTests {

    @Autowired
    UserDao userDao;

    @Test
    void contextLoads() {
        System.out.println(userDao.selectAll());
    }

}
</code></pre>
<h1 id="5-静态资源访问">5. 静态资源访问</h1>
<pre><code class="language-java">// 表名为配置类，自动加载到容器中
@Configuration
public class WebConfig implements WebMvcConfigurer {

    /**
     * 静态资源过滤。
     *
     * @param registry SpringMVC提供。
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 第一个参数为请求Url，第二个表示为本地资源文件夹路径。
        registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);
    }

    /** 自定义拦截器 */
    @Autowired
    UserInterceptor userInterceptor;

    /**
     * 添加拦截器。
     *
     * @param registry SpringMVC提供。
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 添加拦截器，拦截的url
        registry.addInterceptor(userInterceptor).addPathPatterns(&quot;/user&quot;, &quot;/user/*&quot;);
    }
}

// 加入容器
@Component
public class UserInterceptor implements HandlerInterceptor {

    /**
     * 方法(Controller的方法)执行前执行。
     *
     * @param request  请求对象
     * @param response 返回对象
     * @param handler  Controller方法对象（HandlerMethod）
     * @return true继续执行，false直接调到afterCompletion方法。
     * @throws Exception 异常
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(((HandlerMethod) handler).getMethod().getName() + &quot;执行前执行...&quot;);
        return true;
    }

    /**
     * 方法(Controller的方法)执行成功后执行。
     *
     * @param request      请求对象
     * @param response     返回对象
     * @param handler      Controller方法对象（HandlerMethod）
     * @param modelAndView Controller方法对象（HandlerMethod）返回值。
     * @throws Exception 异常
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(((HandlerMethod) handler).getMethod().getName() + &quot;执行完成后执行，返回参数=&quot; + new ObjectMapper().writeValueAsString(modelAndView));
    }

    /**
     * 方法(Controller的方法)执行后执行。
     *
     * @param request  请求对象
     * @param response 返回对象
     * @param handler  Controller方法对象（HandlerMethod）
     * @param ex       Controller方法对象（HandlerMethod）出现的异常对象
     * @throws Exception 异常
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        if (ex != null) {
            System.out.println(((HandlerMethod) handler).getMethod().getName() + &quot;执行后执行, 异常信息：&quot; + ex.getMessage());
        } else {
            System.out.println(((HandlerMethod) handler).getMethod().getName() + &quot;执行后执行&quot;);

        }
    }
}
</code></pre>
<h1 id="6-拦截器">6. 拦截器</h1>
<pre><code class="language-java">// SpringBoot会自动扫描添加到容器中
@RestControllerAdvice
public class ExceptionAdvice {

    /**
     * 拦截位置的所有异常。
     * &lt;p&gt;
     * `@ExceptionHandler(Exception.class)`：表示这一个桶通知，参数表示此通知应用在哪个异常上，包括其子类。
     *
     * @param e 异常对象
     * @return 友好的统一返回对象
     */
    @ExceptionHandler(Exception.class)
    public RequestResult exceptionAdvice(Exception e) {
        // 调试可以打开，便于异常快速处理
        // e.printStackTrace();

        // 短信或邮件通知维护人员
        // 短信或邮件通知开发人员
        return new RequestResult(RequestCode.SYS_ERROR, &quot;系统出现问题，请稍后再试&quot;);
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC高级]]></title>
        <id>https://stackyu.github.io/post/springmvc-gao-ji/</id>
        <link href="https://stackyu.github.io/post/springmvc-gao-ji/">
        </link>
        <updated>2023-01-23T09:12:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-ssm整合">1. SSM整合</h1>
<blockquote>
<p>看以下项目示例代码</p>
</blockquote>
<p>整合框架示例代码：<a href="https://github.com/xiaoyu2017/SSM">SSM</a></p>
<h1 id="2-统一返回结果">2. 统一返回结果</h1>
<pre><code class="language-java">public class RequestResult {
    private Object data;
    private Integer code;
    private String msg;

    public RequestResult() {
    }

    public RequestResult(Object data, Integer code, String msg) {
        this.data = data;
        this.code = code;
        this.msg = msg;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    @Override
    public String toString() {
        return &quot;RequestResult{&quot; +
                &quot;data=&quot; + data +
                &quot;, code=&quot; + code +
                &quot;, msg='&quot; + msg + '\'' +
                '}';
    }

    public static class Code {
        public static final Integer SAVE_OK = 20011;
        public static final Integer DELETE_OK = 20021;
        public static final Integer UPDATE_OK = 20031;
        public static final Integer GET_OK = 20041;
        public static final Integer SAVE_ERR = 20010;
        public static final Integer DELETE_ERR = 20020;
        public static final Integer UPDATE_ERR = 20030;
        public static final Integer GET_ERR = 20040;
    }

}

@RestController
@RequestMapping(&quot;/tag&quot;)
public class TagController {

    @Autowired
    TagService tagService;

    @PostMapping
    public RequestResult save(@RequestBody Tag tag) {
        tagService.save(tag);
        RequestResult requestResult = new RequestResult();
        requestResult.setCode(RequestResult.Code.SAVE_OK);
        requestResult.setMsg(&quot;save tag success&quot;);
        return requestResult;
    }

    @GetMapping
    public RequestResult getAll() throws Exception {
        List&lt;Tag&gt; all = tagService.getAll();
        RequestResult requestResult = new RequestResult();
        requestResult.setCode(RequestResult.Code.GET_OK);
        requestResult.setMsg(&quot;save tag success&quot;);
        requestResult.setData(all);
        return requestResult;
    }

    @GetMapping(&quot;/{id}&quot;)
    public RequestResult getTagById(@PathVariable long id) throws Exception {
        Tag tag = tagService.getById(id);
        RequestResult requestResult = new RequestResult();
        requestResult.setCode(RequestResult.Code.GET_OK);
        requestResult.setMsg(&quot;save tag success&quot;);
        requestResult.setData(tag);
        return requestResult;
    }
}
</code></pre>
<h1 id="3-统一异常处理">3. 统一异常处理</h1>
<blockquote>
<p>在一个项目中随处都可能出现异常，主要的异常分为以下几种：</p>
<ol>
<li>业务异常：用户输入错误的数据格式，用户故意传递错误参数</li>
<li>系统异常：比如服务器或者数据库宕机等</li>
<li>其他异常：文件未找到等</li>
</ol>
<p>对应的异常处理：</p>
<ol>
<li>业务异常：返回友好的提示，警告用户</li>
<li>系统异常：发送固定消息，安抚用户。发送特点消息通知（邮件或短信）系统维护人员，并记录日志。</li>
<li>其他异常：发送固定消息，安抚用户。发送特点消息通知系统维护人员，并记录日志。</li>
</ol>
<p>在哪里统一处理异常了：</p>
<p>在变形层统一管理，将异常分类处理，通过AOP实现统一处理。</p>
</blockquote>
<h2 id="31-简单示例">3.1 简单示例</h2>
<p>1.创建异常处理类：</p>
<pre><code class="language-java">// 表示这是处理rest的controller的通知类
@RestControllerAdvice
public class AppExceptionAdvice {

    // 处理的异常类型
    @ExceptionHandler(Exception.class)
    public RequestResult exceptionHandle(Exception e) {
        // 此处可以发消息（短信或邮件）通知维护人员
        System.out.println(&quot;exceptionHandle get exception=&quot; + e.getMessage());
        return new RequestResult(null, RequestResult.Code.GET_ERR, &quot;系统出现异常，请稍后再试...&quot;);
    }
}
</code></pre>
<p>2.SpringMvc配置文件扫描通知：</p>
<pre><code class="language-java">@EnableWebMvc
@Configuration
// 扫描advice
@ComponentScan({&quot;cn.fishland.controller&quot;, &quot;cn.fishland.config&quot;, &quot;cn.fishland.advice&quot;})
public class SpringMvcConfig {
}
</code></pre>
<p>3.添加异常：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/tag&quot;)
public class TagController {

    @Autowired
    TagService tagService;

    @GetMapping(&quot;/{id}&quot;)
    public RequestResult getTagById(@PathVariable long id) throws Exception {
        // 手动添加异常
        int x = 1 / 0;
        Tag tag = tagService.getById(id);
        RequestResult requestResult = new RequestResult();
        requestResult.setCode(RequestResult.Code.GET_OK);
        requestResult.setMsg(&quot;save tag success&quot;);
        requestResult.setData(tag);
        return requestResult;
    }
}
</code></pre>
<h2 id="32-分异常处理">3.2 分异常处理</h2>
<p>自定义分类异常</p>
<pre><code class="language-java">public class SystemException extends RuntimeException {
    private Integer code;

    public SystemException(String message, Integer code) {
        super(message);
        this.code = code;
    }

    public SystemException(String message, Integer code, Throwable cause) {
        super(message, cause);
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
}

public class UserException extends RuntimeException {
    private Integer code;

    public UserException(String message, Integer code) {
        super(message);
        this.code = code;
    }

    public UserException(String message, Throwable cause, Integer code) {
        super(message, cause);
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
}
</code></pre>
<p>异常处理通知类添加通知：</p>
<pre><code class="language-java">// rest风格控制器通知类
@RestControllerAdvice
public class AppExceptionAdvice {

    // 处理的异常
    @ExceptionHandler(Exception.class)
    public RequestResult exceptionHandle(Exception e) {
        // 此处可以发消息（短信或邮件）通知维护人员
        System.out.println(&quot;exceptionHandle get exception=&quot; + e.getMessage());
        return new RequestResult(null, RequestResult.Code.GET_ERR, &quot;系统出现异常，请稍后再试...&quot;);
    }

    //@ExceptionHandler用于设置当前处理器类对应的异常类型，处理系统错误通知
    @ExceptionHandler(SystemException.class)
    public RequestResult doSystemException(SystemException ex) {
        // 记录日志
        // 发送消息给运维
        // 发送邮件给开发人员,ex对象发送给开发人员
        return new RequestResult(null, ex.getCode(), ex.getMessage());
    }

    // 处理用户错误通知
    @ExceptionHandler(UserException.class)
    public RequestResult doBusinessException(UserException ex) {
        return new RequestResult(null, ex.getCode(), ex.getMessage());
    }
}
</code></pre>
<p>service层异常处理：</p>
<pre><code class="language-java">@Service
public class TagServiceImpl implements TagService {

    @Autowired
    TagDao tagDao;

    @Override
    public List&lt;Tag&gt; getAll() {
        return tagDao.selectAll();
    }

    @Override
    public Boolean save(Tag tag) {
        return tagDao.insert(tag) == 1;
    }

    @Override
    public Tag getById(long id) {
        // 模拟业务异常
        if (id == 1) {
            throw new UserException(&quot;请输入正确的id&quot;, RequestResult.Code.USER_ERR);
        }
        try {
            int x = 1 / 0;
        } catch (Exception e) {
            // 模拟系统异常
            throw new SystemException(&quot;系统出现错误，请稍后再试&quot;, RequestResult.Code.SYSTEM_ERR, e);
        }
        return tagDao.selectById(id);
    }
}
</code></pre>
<h1 id="4-拦截器">4. 拦截器</h1>
<blockquote>
<p>拦截器工作图</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="../../../img/spring10.png" alt="" loading="lazy"></figure>
<blockquote>
<p>拦截器和过滤器的不同</p>
<ol>
<li>归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术</li>
<li>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强</li>
</ol>
</blockquote>
<figure data-type="image" tabindex="2"><img src="../../../img/spring11.png" alt="" loading="lazy"></figure>
<h2 id="41-拦截器简单示例">4.1 拦截器简单示例</h2>
<p>1.创建拦截器：</p>
<pre><code class="language-java">// 需要Spring来管理此类
@Component
public class TagControllerInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;preHandle...&quot;);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandle...&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion...&quot;);
    }
}
</code></pre>
<p>2.Spring配置扫描此类：</p>
<pre><code class="language-java">// Spring配置类
@Configuration
@EnableTransactionManagement
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import({JdbcConfig.class, MybatisConfig.class})
// 扫描拦截器
@ComponentScan({&quot;cn.fishland.service&quot;, &quot;cn.fishland.interceptor&quot;})
public class SpringConfig {
}
</code></pre>
<p>3.SpringMvc配置拦截器：</p>
<pre><code class="language-java">@Configuration
public class WebConfig extends WebMvcConfigurationSupport {

    // 注入拦截器
    @Autowired
    TagControllerInterceptor tagControllerInterceptor;

    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 第一个为拦截的请求url，第二个为本地访问url
        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);
        registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/js/&quot;);
        registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/css/&quot;);
        registry.addResourceHandler(&quot;/plugins/**&quot;).addResourceLocations(&quot;/plugins/&quot;);
    }

    // 拦截器拦截的请求url
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tagControllerInterceptor).addPathPatterns(&quot;/tag/*&quot;).addPathPatterns(&quot;/tag&quot;);
    }
}
</code></pre>
<p>拦截器方法运行顺序：</p>
<figure data-type="image" tabindex="3"><img src="../../../img/spring12.png" alt="" loading="lazy"></figure>
<h2 id="42-拦截器参数">4.2 拦截器参数</h2>
<ol>
<li>前置方法</li>
</ol>
<pre><code class="language-java">@Component
public class TagControllerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception {
        System.out.println(&quot;preHandle...&quot;);
        return true;
    }
}
</code></pre>
<blockquote>
<p>在原始方法执行前执行</p>
<ol>
<li>request：请求对象</li>
<li>response：响应对象</li>
<li>handler：原始的方法method对象</li>
</ol>
</blockquote>
<ol start="5">
<li>后置方法</li>
</ol>
<pre><code class="language-java">@Component
public class TagControllerInterceptor implements HandlerInterceptor {
    @Override
    public void postHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler,
                           ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandle...&quot;);
    }
}
</code></pre>
<blockquote>
<p>原方法执行成功后执行</p>
<ol>
<li>request：请求对象</li>
<li>response：响应对象</li>
<li>handler：原始的方法method对象</li>
<li>modelAndView：原始方法返回的数据和页面信息</li>
</ol>
</blockquote>
<ol start="3">
<li>完成后方法</li>
</ol>
<pre><code class="language-java">@Component
public class TagControllerInterceptor implements HandlerInterceptor {
    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response,
                                Object handler,
                                Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion...&quot;);
    }
}
</code></pre>
<blockquote>
<p>原始方法之后执行，无论原始方法是否执行</p>
<ol>
<li>request：请求对象</li>
<li>response：响应对象</li>
<li>handler：原始的方法method对象</li>
<li>ex：获得原始方法可能出现的异常信息对象</li>
</ol>
</blockquote>
<h2 id="43-多拦截器执行顺序">4.3 多拦截器执行顺序</h2>
<blockquote>
<p>当一个控制器方法出现多个拦截器，执行顺序是先进后出，类似栈。顺序就是配置的顺序。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="../../../img/spring13.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">@Configuration
public class WebConfig extends WebMvcConfigurationSupport {

    // 注入拦截器
    @Autowired
    TagControllerInterceptor tagControllerInterceptor;

    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 第一个为拦截的请求url，第二个为本地访问url
        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);
        registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/js/&quot;);
        registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/css/&quot;);
        registry.addResourceHandler(&quot;/plugins/**&quot;).addResourceLocations(&quot;/plugins/&quot;);
    }

    // 拦截器拦截的请求url
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(tagControllerInterceptor).addPathPatterns(&quot;/tag/*&quot;).addPathPatterns(&quot;/tag&quot;);
        registry.addInterceptor(xxxInterceptor).addPathPatterns(&quot;/tag/*&quot;).addPathPatterns(&quot;/tag&quot;);
        registry.addInterceptor(xxxInterceptor).addPathPatterns(&quot;/tag/*&quot;).addPathPatterns(&quot;/tag&quot;);
        // ...
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC基础]]></title>
        <id>https://stackyu.github.io/post/springmvc/</id>
        <link href="https://stackyu.github.io/post/springmvc/">
        </link>
        <updated>2023-01-23T09:10:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-入门示例">1. 入门示例</h1>
<ol>
<li>添加依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;version&gt;2.5&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>添加SpringMvc容器配置</li>
</ol>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;cn.fishland.controller&quot;)
@Import({ServletConfig.class})
public class SpringMvcConfig {
}
</code></pre>
<ol start="3">
<li>添加web.xml代替配置类</li>
</ol>
<pre><code class="language-java">// 配置类代替web.xml文件
public class ServletConfig extends AbstractDispatcherServletInitializer {

    // 获得SpringMvc配置文件
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(SpringMvcConfig.class);
        return context;
    }

    // SpringMvc拦截的所有请求
    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }

    // Spring配置文件
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
</code></pre>
<ol start="4">
<li>创建Controller</li>
</ol>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String mvcTest() {
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<ol start="5">
<li>运行测试</li>
</ol>
<p>添加tomcat插件</p>
<pre><code class="language-xml">&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
            &lt;port&gt;80&lt;/port&gt;
            &lt;path&gt;/&lt;/path&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<p>执行运行命令：<code>tomcat7:run</code></p>
<p>也可以配置运行：</p>
<figure data-type="image" tabindex="1"><img src="../../../img/spring9.png" alt="" loading="lazy"></figure>
<h1 id="2-spring和springmvc分开加载业务bean">2. Spring和SpringMvc分开加载业务bean</h1>
<ol>
<li>通过详细包配置分开</li>
</ol>
<pre><code class="language-java">@Configuration
// 通过详细包配置
@ComponentScan({&quot;cn.fishland.service&quot;, &quot;cn.fishland.dao&quot;})
public class SpringConfig {
}
</code></pre>
<ol start="2">
<li>通过排除配置进行配置</li>
</ol>
<pre><code class="language-java">@Configuration
// 通过属性配置排除不需要加载的bean
@ComponentScan(value = &quot;cn.fishland&quot;,
        excludeFilters = @ComponentScan.Filter(
                type = FilterType.ANNOTATION,
                classes = Controller.class))
public class SpringConfig {
}
</code></pre>
<ul>
<li>excludeFilters：bean扫描时过滤的规则
<ul>
<li>type：配置排除规则
<ul>
<li>ANNOTATION：按照注解排除</li>
<li>ASSIGNABLE_TYPE:按照指定的类型过滤</li>
<li>ASPECTJ:按照Aspectj表达式排除，基本上不会用</li>
<li>REGEX:按照正则表达式排除</li>
<li>CUSTOM:按照自定义规则排除</li>
</ul>
</li>
<li>classes：规则具体条件</li>
</ul>
</li>
</ul>
<h1 id="3-加载spring配置">3. 加载Spring配置</h1>
<pre><code class="language-java">// 配置类代替web.xml文件
public class ServletConfig extends AbstractDispatcherServletInitializer {

    // 获得SpringMvc配置文件
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(SpringMvcConfig.class);
        return context;
    }

    // SpringMvc拦截的所有请求
    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }

    // Spring配置文件
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(SpringConfig.class);
        return context;
    }
}
</code></pre>
<p>加载配置简化版：</p>
<pre><code class="language-java">// 简化配置类
public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }
}
</code></pre>
<h1 id="4-接收请求参数">4. 接收请求参数</h1>
<h2 id="41-单个参数">4.1 单个参数</h2>
<p>参数名和controller形参名一样即可：</p>
<p><code>http://localhost/test?name=fish</code></p>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    // 形参名称和请求参数名称相同即可
    public String mvcTest(String name) {
        System.out.println(&quot;test request name=&quot; + name);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<h2 id="42-多个参数">4.2 多个参数</h2>
<ol>
<li>多个形参</li>
</ol>
<p><code>http://localhost/test?name=fish&amp;age=18</code></p>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test1&quot;)
    @ResponseBody
    public String mvcTest1(String name, int age) {
        System.out.println(&quot;test request name=&quot; + name);
        System.out.println(&quot;test request age=&quot; + age);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<ol start="2">
<li>实体类接收</li>
</ol>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test3&quot;)
    @ResponseBody
    public String mvcTest3(User user) {
        System.out.println(user);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<p><code>http://localhost/test3?name=fish&amp;age=18</code></p>
<ol start="3">
<li>级联传参</li>
</ol>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test4&quot;)
    @ResponseBody
    public String mvcTest4(User user) {
        System.out.println(user);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<p><code>http://localhost/test4?name=fish&amp;age=18&amp;role.roleName=admin&amp;role.roleType=1</code></p>
<h2 id="43-集合">4.3 集合</h2>
<p>数组：</p>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test5&quot;)
    @ResponseBody
    public String mvcTest5(String[] likes) {
        System.out.println(Arrays.toString(likes));
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}

</code></pre>
<p><code>http://localhost/test5?likes=likes1&amp;likes=likes2&amp;likes=likes3</code></p>
<p>集合：</p>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test6&quot;)
    @ResponseBody
    // 集合需要添加@RequestParam注解
    public String mvcTest6(@RequestParam List&lt;String&gt; likes) {
        System.out.println(likes);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<p><code>http://localhost/test6?likes=likes1&amp;likes=likes2&amp;likes=likes3</code></p>
<h2 id="44-名称不相同">4.4 名称不相同</h2>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test7&quot;)
    @ResponseBody
    // 添加@RequestParam注解，指定请求参数名称即可
    public String mvcTest7(@RequestParam(&quot;userName&quot;) String name) {
        System.out.println(&quot;name=&quot; + name);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<p><code>http://localhost/test7?userName=fish</code></p>
<h2 id="45-请求中文乱码">4.5 请求中文乱码</h2>
<p>修改tomcat编码处理Get中文乱码：</p>
<pre><code class="language-xml">&lt;plugins&gt;
  &lt;plugin&gt;
    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
    &lt;configuration&gt;
      &lt;port&gt;80&lt;/port&gt;
      &lt;path&gt;/&lt;/path&gt;
      &lt;!--添加中文字符集--&gt;
      &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;
    &lt;/configuration&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<p>处理Post中文乱码问题：</p>
<pre><code class="language-java">// 在配置类中添加过滤器
public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return new Class[]{SpringConfig.class};
  }

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class[]{SpringMvcConfig.class};
  }

  @Override
  protected String[] getServletMappings() {
    return new String[]{&quot;/&quot;};
  }

  @Override
  protected Filter[] getServletFilters() {
    // 添加字符过滤器
    CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
    characterEncodingFilter.setEncoding(&quot;UTF-8&quot;);
    return new Filter[]{characterEncodingFilter};
  }
}
</code></pre>
<h2 id="46-json参数">4.6 Json参数</h2>
<p>添加Json依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>主配置类开启Json转换:</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;cn.fishland.controller&quot;)
@Import({ServletConfig.class})
// 开启json数据类型自动转换
@EnableWebMvc
public class SpringMvcConfig {
}
</code></pre>
<p>Controller编写：</p>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test9&quot;)
    @ResponseBody
    // 需要添加@RequestBody注解将Json转换成对象
    public String mvcTest9(@RequestBody Role role) {
        System.out.println(role);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<h2 id="47-日期参数">4.7 日期参数</h2>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test10&quot;)
    @ResponseBody
    // 添加参数解析非默认日期格式，默认是可以解析yyyy/MM/dd的.
    public String mvcTest10(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date date) {
        System.out.println(date);
        return &quot;{'msg':'request mvc test success'}&quot;;
    }
}
</code></pre>
<h1 id="5-数据响应">5. 数据响应</h1>
<ol>
<li>响应数据</li>
</ol>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test11&quot;)
    // 配置改注解表示当前请求返回的是文本数据
    @ResponseBody
    public String mvcTest11() {
        System.out.println(&quot;mvcTest11 run...&quot;);
        return &quot;page.jsp&quot;;
    }
}
</code></pre>
<ol start="2">
<li>响应界面</li>
</ol>
<pre><code class="language-java">@Controller
public class HomeController {
    @RequestMapping(&quot;/test11&quot;)
    // 去掉@ResponseBody注解表示返回的String将被解析成页面名称，并把页面返回。
    // @ResponseBody
    public String mvcTest11() {
        System.out.println(&quot;mvcTest11 run...&quot;);
        return &quot;page.jsp&quot;;
    }
}
</code></pre>
<h1 id="6-rest编程风格">6. Rest编程风格</h1>
<h2 id="61-各个请求方法controller">6.1 各个请求方法Controller</h2>
<pre><code class="language-java">@Controller
@ResponseBody
@RequestMapping(&quot;/user&quot;)
public class UserController {

    /**
     * 新增User使用POST请求
     */
    @RequestMapping(value = &quot;/add&quot;,method = RequestMethod.POST)
    public String add(User user) {
        System.out.println(&quot;user=&quot; + user + &quot; add...&quot;);
        return &quot;{'msg':'add user success'}&quot;;
    }

    /**
     * 删除User不需要传参，可以从请求路径中获得参数。请求方法DELETE
     * `@PathVariable`获得路径参数
     */
    @RequestMapping(value = &quot;/delete/{id}&quot;,method = RequestMethod.DELETE)
    public String delete(@PathVariable(&quot;id&quot;)int userId) {
        System.out.println(&quot;delete user id=&quot; + userId + &quot; ...&quot;);
        return &quot;{'msg':'delete user success'}&quot;;
    }

    /**
     * 修改User请求方法PUT
     */
    @RequestMapping(value = &quot;/update&quot;,method = RequestMethod.PUT)
    public String update(@RequestBody User user) {
        System.out.println(&quot;update user=&quot; + user + &quot; ...&quot;);
        return &quot;{'msg':'update user success'}&quot;;
    }

    /**
     * 删除User不需要传参，可以从请求路径中获得参数。请求方法PUT
     * `@PathVariable`获得路径参数，占位符名称和形参相同就不需要改
     */
    @RequestMapping(value = &quot;/get/{id}&quot;,method = RequestMethod.GET)
    public String get(@PathVariable int id) {
        System.out.println(&quot;get user id=&quot; + id + &quot; ...&quot;);
        return &quot;{'msg':'get user success'}&quot;;
    }
}
</code></pre>
<h2 id="62-简写版">6.2 简写版</h2>
<pre><code class="language-java">//@Controller
//@ResponseBody
// 以上两个注解合集
@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {

    /**
     * 新增User使用POST请求
     */
    // @RequestMapping(value = &quot;/add&quot;, method = RequestMethod.POST)
    @PostMapping //以上注解替换，不再添加url，通过请求方式辨别功能
    public String add(@RequestBody User user) {
        System.out.println(&quot;user=&quot; + user + &quot; add...&quot;);
        return &quot;{'msg':'add user success'}&quot;;
    }

    /**
     * 删除User不需要传参，可以从请求路径中获得参数。请求方法DELETE
     * `@PathVariable`获得路径参数
     */
//    @RequestMapping(value = &quot;/delete/{id}&quot;, method = RequestMethod.DELETE)
    @DeleteMapping(&quot;/{id}&quot;) // 需要参数，所有需要添加url
    public String delete(@PathVariable(&quot;id&quot;) int userId) {
        System.out.println(&quot;delete user id=&quot; + userId + &quot; ...&quot;);
        return &quot;{'msg':'delete user success'}&quot;;
    }

    /**
     * 修改User请求方法PUT
     */
//    @RequestMapping(value = &quot;/update&quot;, method = RequestMethod.PUT)
    @PutMapping
    public String update(@RequestBody User user) {
        System.out.println(&quot;update user=&quot; + user + &quot; ...&quot;);
        return &quot;{'msg':'update user success'}&quot;;
    }

    /**
     * 删除User不需要传参，可以从请求路径中获得参数。请求方法PUT
     * `@PathVariable`获得路径参数
     */
//    @RequestMapping(value = &quot;/get/{id}&quot;, method = RequestMethod.GET)
    @GetMapping(&quot;/{id}&quot;)
    public String get(@PathVariable int id) {
        System.out.println(&quot;get user id=&quot; + id + &quot; ...&quot;);
        return &quot;{'msg':'get user success'}&quot;;
    }
}
</code></pre>
<h1 id="7-开放静态资源">7. 开放静态资源</h1>
<p>编写配置类：</p>
<pre><code class="language-java">@Configuration
public class WebConfig extends WebMvcConfigurationSupport {

    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 第一个为拦截的请求url，第二个为本地访问url
        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);
        registry.addResourceHandler(&quot;/js/**&quot;).addResourceLocations(&quot;/js/&quot;);
        registry.addResourceHandler(&quot;/css/**&quot;).addResourceLocations(&quot;/css/&quot;);
        registry.addResourceHandler(&quot;/plugins/**&quot;).addResourceLocations(&quot;/plugins/&quot;);
    }
}
</code></pre>
<p>主配置扫描：</p>
<pre><code class="language-java">@Configuration
@ComponentScan({&quot;cn.fishland.controller&quot;, &quot;cn.fishland.config&quot;})
@Import(ServletConfig.class)
// 开启json数据类型自动转换
@EnableWebMvc
public class SpringMvcConfig {
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringAOP基础知识]]></title>
        <id>https://stackyu.github.io/post/springaop-ji-chu-zhi-shi/</id>
        <link href="https://stackyu.github.io/post/springaop-ji-chu-zhi-shi/">
        </link>
        <updated>2023-01-22T02:54:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-aop">1. AOP</h1>
<blockquote>
<p>AOP一种编程思想，在不改变源代码前提下对其进行功能增强。</p>
</blockquote>
<p>AOP专业术语：</p>
<ol>
<li>连接点：待增强方法</li>
<li>切入点：被增强方法</li>
<li>通知类：编写增强方法的类</li>
<li>通知：增强方法</li>
<li>切面：通知增强连接点的关系描述</li>
<li>目标类：需要被代理的类</li>
<li>代理：通过代理目标对象创建的对象</li>
</ol>
<figure data-type="image" tabindex="1"><img src="../../../img/spring2.png" alt="" loading="lazy"></figure>
<h1 id="2-入门">2. 入门</h1>
<p>准备类：</p>
<pre><code class="language-java">public interface UserDao {
    void insert();

    void add();
}

@Repository
public class UserDaoImpl implements UserDao {
    public void insert() {
        System.out.println(&quot;UserDaoImpl insert run...&quot;);
    }

    public void add() {
        System.out.println(&quot;UserDaoImpl add run...&quot;);
    }
}
</code></pre>
<p>1.添加依赖：SpringAOP是依赖Aspect开源框架，所以需要添加依赖。</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2.编写通知类及通知等：</p>
<pre><code class="language-java">// 装配组件注解
@Component
// 通知类注解
@Aspect
public class DaoAdvice {

    // 切入点
    @Pointcut(&quot;execution(void cn.fishland.dao.UserDao.insert())&quot;)
    public void pt() {
    }

    // 切面
    @Before(&quot;pt()&quot;) // 方法执行前
    // 通知
    public void showTime() {
        System.out.println(System.currentTimeMillis());
    }
}
</code></pre>
<p>3.主配置类开启AOP：</p>
<pre><code class="language-java">@Configuration
// 开启AOP功能
@EnableAspectJAutoProxy
@ComponentScan(&quot;cn.fishland&quot;)
public class AppConfig {
}
</code></pre>
<p>4.测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserDao bean = context.getBean(UserDao.class);
        bean.insert();
        System.out.println(&quot;=========================&quot;);
        bean.add();
    }
}
</code></pre>
<h1 id="3-aop工作流程">3. AOP工作流程</h1>
<ol>
<li>容器加载bean和通知类，但是此时被增强类并未创建。</li>
<li>加载切入点，只加载被应用的切入点。</li>
<li>为增强类创建代理类，未增强类创建原始类。</li>
<li>通过容器获得bean</li>
</ol>
<h1 id="4-aop详细配置">4. AOP详细配置</h1>
<h2 id="41-切入点表达式">4.1 切入点表达式</h2>
<blockquote>
<p>切入点通常配置的较多，如果单独配置会出现很多，这时就有通配符等解决办法。</p>
</blockquote>
<h3 id="411-语法格式">4.1.1 语法格式</h3>
<p><code>@Pointcut(&quot;动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名)&quot;));</code></p>
<ol>
<li>动作关键字：execution表示执行到切入点</li>
<li>访问修饰符：一般不写，通常情况下被增强方法修饰符都是public，当然也可以其他</li>
<li>返回值：不可省略</li>
<li>包名.类/接口名.方法名(参数)：类的全路径名称加方法和参数</li>
<li>异常：可省略</li>
</ol>
<p>示例：<code>@Pointcut(&quot;execution(void cn.fishland.dao.UserDao.insert())&quot;)</code></p>
<blockquote>
<p>关于方法配接口还是实现类，其实是都可以的，但是通常使用的是接口方法路径名，配实现类的话耦合度较高。</p>
</blockquote>
<h3 id="412-通配符">4.1.2 通配符</h3>
<ol>
<li><code>*</code>：表示任意个符号</li>
</ol>
<p>示例：<code>execution（public * cn.fishland.*.UserService.find*(*))</code></p>
<p>表示返回值任意，cn.fishland包下任意包的UserService接口的以find开头的方法，形参为一个。</p>
<ol start="2">
<li><code>..</code>：表示多个连续符号</li>
</ol>
<p>示例<code>execution（public User cn..UserService.findById(..))</code></p>
<p>匹配返回值为User，cn包下任意包下UserService接口的findById方法，参数为任意个。</p>
<ol start="3">
<li><code>+</code>：表示匹配子类</li>
</ol>
<p>示例：<code>execution(* *..*Service+.*(..))</code></p>
<p>返回值任意，任意包下以Service结尾的子类的任一方法，参数任意个。</p>
<p><strong>符号表示单个单词或者标识符，例如cn、fishland、User都是的</strong></p>
<h3 id="413-配置规范">4.1.3 配置规范</h3>
<ol>
<li>切入点类<strong>通常描述接口</strong></li>
<li>访问修饰符一般省略</li>
<li>增删改返回值使用精确类型，查询使用通配符*</li>
<li>包尽量不使用..通配符，可以使用*通配符，尽量精确包名</li>
<li>类或接口名书写一般采用*加结尾，例如服务层<code>*Service</code></li>
<li>方法名，动词精确匹配，名称采用匹配</li>
</ol>
<h2 id="42-通知类">4.2 通知类</h2>
<blockquote>
<p>通知类型处理示例中的前置通知外还有其他四种，后置通知、环绕通知、返回后通知和异常通知。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="../../../img/spring3.png" alt="" loading="lazy"></figure>
<p>测试类：</p>
<pre><code class="language-java">public interface UserDao {
    void insert();

    void add();

    void select();
}

@Repository
public class UserDaoImpl implements UserDao {
    public void insert() {
        System.out.println(&quot;UserDaoImpl insert run...&quot;);
    }

    public void add() {
        int x = 1 / 0;
        System.out.println(&quot;UserDaoImpl add run...&quot;);
    }

    public void select() {
        System.out.println(&quot;UserDaoImpl select run...&quot;);
    }
}
</code></pre>
<p>多种通知类型配置：</p>
<pre><code class="language-java">@Component
// 通知类注解
@Aspect
public class DaoAdvice {

    // 切入点
    @Pointcut(&quot;execution(void cn.fishland.dao.UserDao.insert())&quot;)
    public void ptInsert() {
    }

    // 切入点
    @Pointcut(&quot;execution(void cn.fishland.dao.UserDao.add())&quot;)
    public void ptAdd() {
    }

    // 切入点
    @Pointcut(&quot;execution(void cn.fishland.dao.UserDao.select())&quot;)
    public void ptSelect() {
    }

    // 前置通知
    @Before(&quot;ptInsert()&quot;)
    public void before() {
        System.out.println(&quot;insert method before...&quot;);
    }

    // 返回后通知
    @AfterReturning(&quot;ptInsert()&quot;)
    public void afterReturning() {
        System.out.println(&quot;insert method afterReturning...&quot;);
    }

    // 后置通知
    @After(&quot;ptInsert()&quot;)
    public void after() {
        System.out.println(&quot;insert method after...&quot;);
    }

    // 异常通知
    @AfterThrowing(&quot;ptAdd()&quot;)
    public void afterThrowing() {
        System.out.println(&quot;add method after...&quot;);
    }

    // 环绕通知
    @Around(&quot;ptSelect()&quot;)
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&quot;select method around before...&quot;);
        Object proceed = pjp.proceed();
        System.out.println(&quot;select method around after...&quot;);
        return proceed;
    }
}
</code></pre>
<p>环绕通知注意：</p>
<ol>
<li>环绕通知需要有参数ProceedingJoinPoint用于操作目标类方法</li>
<li>环绕通知最好有返回值，切入点有参数，环绕通知必须有，切入点为void，环绕通知可以为Object或void</li>
<li>需要对目标方法调用进行异常处理</li>
</ol>
<h1 id="5-通知获得参数">5. 通知获得参数</h1>
<blockquote>
<p>在为切入点进行功能增强时，不仅仅增加一些功能，还需要对数据进行处理，主要的处理为切入点参数、返回值和异常数据。</p>
</blockquote>
<ol>
<li>切入点参数：所有通知都适合获取
<ol>
<li>JoinPoint：前置、返回后、异常后和后置</li>
<li>ProceedingJoinPoint：环绕通知</li>
</ol>
</li>
<li>切入点返回值：前置和异常后没有返回值，后置方法可有可无，所以适合获得返回值的是有返回后和环绕。
<ol>
<li>返回后通知</li>
<li>环绕通知</li>
</ol>
</li>
<li>异常：只适合环绕和异常后
<ol>
<li>异常后通知</li>
<li>环绕通知</li>
</ol>
</li>
</ol>
<h2 id="51-切入点参数">5.1 切入点参数</h2>
<pre><code class="language-java">@Component
// 通知类注解
@Aspect
public class DaoAdvice {
    // 切入点
    @Pointcut(&quot;execution(void cn.fishland.dao.UserDao.add(..))&quot;)
    public void ptAdd() {
    }

    // 前置通知
    @Before(&quot;ptAdd()&quot;)
    public void before(JoinPoint joinPoint) {
        System.out.println(&quot;before advice get args=&quot; + Arrays.toString(joinPoint.getArgs()));
    }

    // 返回后通知
    @AfterReturning(&quot;ptAdd()&quot;)
    public void afterReturning(JoinPoint joinPoint) {
        System.out.println(&quot;afterReturning advice get args=&quot; + Arrays.toString(joinPoint.getArgs()));
    }

    // 异常后通知
    @AfterThrowing(&quot;ptAdd()&quot;)
    public void afterThrow(JoinPoint joinPoint) {
        System.out.println(&quot;afterThrow advice get args=&quot; + Arrays.toString(joinPoint.getArgs()));
    }

    // 后置通知
    @After(&quot;ptAdd()&quot;)
    public void after(JoinPoint joinPoint) {
        System.out.println(&quot;after advice get args=&quot; + Arrays.toString(joinPoint.getArgs()));
    }

    // 环绕通知
    @Around(&quot;ptAdd()&quot;)
    public Object around(ProceedingJoinPoint point) {
        Object proceed = null;
        try {
            System.out.println(&quot;around advice get args=&quot;+Arrays.toString(point.getArgs()));
            proceed = point.proceed();
            System.out.println(&quot;around advice end...&quot;);
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return proceed;
    }
}

@Repository
public class UserDaoImpl implements UserDao {

   public void add(User user) {
      System.out.println(&quot;UserDaoImpl add...&quot;);
      for (int i = 0; i &lt; 10000; i++) {
         System.out.print(&quot;wait&quot; + i + &quot; &quot;);
      }
      System.out.println();
      // 去掉下面注释，会访问异常后通知
      // throw new RuntimeException(&quot;....&quot;);
   }
}

</code></pre>
<h2 id="52-切入点返回值">5.2 切入点返回值</h2>
<pre><code class="language-java">@Component
// 通知类注解
@Aspect
public class DaoAdvice {
    // 切入点
    @Pointcut(&quot;execution(* cn.fishland.dao.UserDao.getBy*(..))&quot;)
    public void ptGet() {
    }

    // 返回后通知获得返回值
    @AfterReturning(value = &quot;ptGet()&quot;, returning = &quot;user&quot;)
    public void getAfterReturning(User user) {
        System.out.println(&quot;getAfterReturning return param=&quot; + user.toString());
    }

    // 环绕通知获得返回值
    @Around(value = &quot;ptGet()&quot;)
    public Object getAround(ProceedingJoinPoint joinPoint) {
        Object proceed = null;
        try {
            proceed = joinPoint.proceed();
            System.out.println(&quot;getAround return param=&quot; + proceed.toString());
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return proceed;
    }
}

@Repository
public class UserDaoImpl implements UserDao {
   public User getById(int id) {
      User user = new User();
      user.setId(1);
      user.setName(&quot;fish&quot;);
      System.out.println(&quot;UserDaoImpl getById...&quot;);
      return user;
   }
}

</code></pre>
<h2 id="53-获得异常">5.3 获得异常</h2>
<pre><code class="language-java">@Component
// 通知类注解
@Aspect
public class DaoAdvice {

    // 切入点
    @Pointcut(&quot;execution(* cn.fishland.dao.UserDao.update(..))&quot;)
    public void ptUpdate() {
    }

    // 异常后获得异常
    @AfterThrowing(value = &quot;ptUpdate()&quot;, throwing = &quot;e&quot;)
    public void updateAfterThrowing(Throwable e) {
        System.out.println(&quot;updateAfterThrowing exception e=&quot; + e.getMessage());
    }

    // 环绕获得异常
    @Around(&quot;ptUpdate()&quot;)
    public Object updateAround(ProceedingJoinPoint joinPoint) {
        Object proceed = null;
        try {
            proceed = joinPoint.proceed();
        } catch (Throwable e) {
            System.out.println(&quot;updateAround exception e=&quot; + e.getMessage());
        }
        return proceed;
    }

}

@Repository
public class UserDaoImpl implements UserDao {
   public void update(User user) {
      System.out.println(&quot;UserDaoImpl update...&quot;);
      throw new NullPointerException(&quot;UserDaoImpl update exception&quot;);
   }
}

</code></pre>
<h1 id="6-aop简单应用">6. AOP简单应用</h1>
<h2 id="61-计算dao耗时">6.1 计算Dao耗时</h2>
<blockquote>
<p>计算每次操作数据库的方法耗时</p>
</blockquote>
<pre><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {

   @Override
   public User getById(int id) {
      System.out.println(&quot;UserDaoImpl getById...&quot;);
      for (int i = 0; i &lt; 10000; i++) {
         System.out.print(i + &quot;,&quot;);
      }
      System.out.println();
      return null;
   }

   @Override
   public List&lt;User&gt; getAll() {
      System.out.println(&quot;UserDaoImpl getAll...&quot;);
      for (int i = 0; i &lt; 10000; i++) {
         System.out.print(i + &quot;,&quot;);
      }
      System.out.println();
      return null;
   }
}

@Component
// 通知类注解
@Aspect
public class DaoAdvice {
   // 切入点
   @Pointcut(&quot;execution(* cn.fishland.dao.UserDao.get*(..))&quot;)
   public void ptGet() {
   }

   // 环绕通知
   @Around(&quot;ptGet()&quot;)
   public Object getAround(ProceedingJoinPoint joinPoint) {
      Object proceed = null;
      try {
         long l = System.currentTimeMillis();
         proceed = joinPoint.proceed();
         // 计算耗时
         System.out.println(&quot;use time:&quot; + (System.currentTimeMillis() - l));
      } catch (Throwable e) {
         System.out.println(&quot;updateAround exception e=&quot; + e.getMessage());
      }
      return proceed;
   }

}
</code></pre>
<h2 id="61-预处理参数">6.1 预处理参数</h2>
<blockquote>
<p>去掉参数的前后空格，使用环绕通知</p>
</blockquote>
<pre><code class="language-java">public interface UserDao {
   User getByName(String name);
}

@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public User getByName(String name) {
        System.out.println(&quot;UserDaoImpl getByName name=&quot; + name);
        return null;
    }
}

@Component
// 通知类注解
@Aspect
public class DaoAdvice {
   // 切入点
   @Pointcut(&quot;execution(* cn.fishland.dao.UserDao.get*(..))&quot;)
   public void ptGet() {
   }

   // 前置通知处理参数问题
   @Around(&quot;ptGet()&quot;)
   public Object getAround(ProceedingJoinPoint joinPoint) {
      Object proceed = null;
      try {
         Object[] args = joinPoint.getArgs();
         // 处理所有String类型
         for (int i = 0; i &lt; args.length; i++) {
            if (args[i].getClass().equals(String.class)) {
                // 去除参数前后空格
               args[i] = ((String) args[i]).trim();
            }
         }

         proceed = joinPoint.proceed(args);
      } catch (Throwable e) {
         e.printStackTrace();
      }
      return proceed;
   }
}

</code></pre>
<h1 id="7-aop管理事务">7. AOP管理事务</h1>
<blockquote>
<p>事务在数据库中很重要，主要用于处理一些异常导致的数据问题。在Spring中提供两种事务使用方式，声明事务和编程事务。</p>
</blockquote>
<h2 id="71-简单案例">7.1 简单案例</h2>
<blockquote>
<p>同时操作两行数据，模拟转账，一个用户钱减少另一个增加。</p>
</blockquote>
<pre><code class="language-java">public interface AccountMapper {

    @Update(&quot;update account set money = money - #{money} where id = #{out}&quot;)
    void outMoney(@Param(&quot;out&quot;) int out,@Param(&quot;money&quot;) double money);

    @Update(&quot;update account set money = money + #{money} where id = #{in}&quot;)
    void inMoney(@Param(&quot;in&quot;) int in,@Param(&quot;money&quot;) double money);
}

@Service
public class AccountServiceImpl implements AccountService {

   @Autowired
   AccountMapper accountMapper;

   @Transactional
   public boolean trnsfer(int out, int in, Double money) {

      accountMapper.outMoney(out, money);

      // 此处出现异常，事务就会自动回滚，数据都不会进行修改
      int i = 1 / 0;

      accountMapper.inMoney(in, money);

      return true;
   }
}

@Configuration
@ComponentScan(&quot;cn.fishland&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import({JdbcConfig.class, MybatisConfig.class})
// 开启事务管理
@EnableTransactionManagement
public class Appconfig {

   // 装配事务管理
   @Bean
   public PlatformTransactionManager platformTransactionManager(DataSource dataSource) {
      DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
      dataSourceTransactionManager.setDataSource(dataSource);
      return dataSourceTransactionManager;
   }
}


// 测试
public class Application {
   public static void main(String[] args) {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Appconfig.class);
      AccountService accountService = context.getBean(AccountService.class);
      accountService.trnsfer(1, 2, 100d);
   }
}
</code></pre>
<blockquote>
<p>事务注解可以放在类方法上也可放在类上，实现类和接口类都行，<strong>一般放在实现类上</strong>。</p>
</blockquote>
<h2 id="72-事务角色">7.2 事务角色</h2>
<blockquote>
<p>事务角色分为事务管理员和事务协调员</p>
</blockquote>
<p>在不添加事务管理的情况下：</p>
<ol>
<li>开启事务一，运行后自动提交</li>
</ol>
<figure data-type="image" tabindex="3"><img src="../../../img/spring4.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>开始事务二，运行后自动提交</li>
</ol>
<figure data-type="image" tabindex="4"><img src="../../../img/spring5.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>当以上一二步骤之间出现异常，事务一正常提交，并不会回滚。</li>
</ol>
<p>当添加Spring事务之后：</p>
<p>事务管理员会把单独的事务一和二统一起来管理，事务协调员代指dao或业务层。</p>
<figure data-type="image" tabindex="5"><img src="../../../img/spring7.png" alt="" loading="lazy"></figure>
<h2 id="73-事务注解属性">7.3 事务注解属性</h2>
<figure data-type="image" tabindex="6"><img src="../../../img/spring8.png" alt="" loading="lazy"></figure>
<ol>
<li>readOnly：true只读事务，false读写事务。</li>
<li>timeout：设置事务超时时长单位为秒。-1表示不设置时长</li>
<li>rollbackFor：设置出现指定异常进行回滚。
<ol>
<li>并不是所有异常都会进行回滚，只有RuntimeException和Error这两个异常及其子类才会进行回滚。</li>
</ol>
</li>
<li>noRollbackFor：设置出现指定异常不进行回滚</li>
<li>rollbackForClassName：同rollbackFor，值为异常全类名字符串</li>
<li>noRollbackForClassName：同于noRollbackFor，只不过属性为异常的类全名字符串</li>
<li>isolation：设置事务隔离级别
<ol>
<li>DEFAULT :默认隔离级别, 会采用数据库的隔离级别</li>
<li>READ_UNCOMMITTED : 读未提交</li>
<li>READ_COMMITTED : 读已提交</li>
<li>REPEATABLE_READ : 重复读取</li>
<li>SERIALIZABLE: 串行化</li>
</ol>
</li>
</ol>
<h2 id="74-事务传播行为">7.4 事务传播行为</h2>
<blockquote>
<p>提出问题，在进行转账后需要添加事务，无论是否成功都需要添加日志，如果正常添加就会出现问题。</p>
</blockquote>
<p>正常思路问题代码：</p>
<pre><code class="language-java">public interface LogService {

    List&lt;Account&gt; getAll();

    boolean add(Log log);
}

@Service
public class LogServiceImpl implements LogService {

   @Autowired
   LogMapper logMapper;

   public List&lt;Account&gt; getAll() {
      return logMapper.selectAll();
   }

   @Transactional
   public boolean add(Log log) {
      return logMapper.insert(log) == 1;
   }
}

@Service
public class AccountServiceImpl implements AccountService {

   @Autowired
   AccountMapper accountMapper;

   @Autowired
   LogService logService;

   @Transactional
   public boolean trnsfer(int out, int in, Double money) {
      boolean flag = false;
      try {
         accountMapper.outMoney(out, money);
         // 出现异常后所有事务都会回滚，日志也不会提交
         int x = 1 / 0;
         accountMapper.inMoney(in, money);
         flag = true;
         return true;
      } finally {
         logService.add(new Log(&quot;trnsfer money &quot; + flag, new Date()));
      }
   }
}
</code></pre>
<blockquote>
<p>解决思路，日志操作事务与转账操作分开，是单独的事务。Spring中用到的是事务传播行为。</p>
</blockquote>
<p>设置一下事务传播行为即可：</p>
<pre><code class="language-java">@Service
public class LogServiceImpl implements LogService {

    @Autowired
    LogMapper logMapper;

    public List&lt;Account&gt; getAll() {
        return logMapper.selectAll();
    }

    // 开启一个新的事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public boolean add(Log log) {
        return logMapper.insert(log) == 1;
    }
}
</code></pre>
<p>事务传播行为：</p>
<table>
<thead>
<tr>
<th>传播属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Required（默认值）</td>
<td>当前存在事务就加入，不存在就创建</td>
</tr>
<tr>
<td>Support</td>
<td>当前存在事务就加入，不存在就以非事务形式执行</td>
</tr>
<tr>
<td>Mandatory</td>
<td>当前存在事务就加入，不存在事务就报错</td>
</tr>
<tr>
<td>Required_new</td>
<td>无论当前是否存在事务，都会新建事务</td>
</tr>
<tr>
<td>no_support</td>
<td>以非事务形式运行，当前存在事务就挂起</td>
</tr>
<tr>
<td>never</td>
<td>以非事务形式运行，当前存在事务就报错</td>
</tr>
<tr>
<td>nested</td>
<td>当前存在事务就在嵌套事务中运行，不存在就执行Required传播行为</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring基础知识]]></title>
        <id>https://stackyu.github.io/post/spring-ji-chu-zhi-shi/</id>
        <link href="https://stackyu.github.io/post/spring-ji-chu-zhi-shi/">
        </link>
        <updated>2023-01-18T16:30:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1. 概述</h1>
<blockquote>
<p>Spring是整合框架、简化开发的框架，主要的技术为IOC、DI、AOP和事务等。可以理解为它是一个管家，管理者项目中的对象，集精华框架不重复造轮子。</p>
</blockquote>
<p>框架架构图：</p>
<figure data-type="image" tabindex="1"><img src="../../img/spring0.png" alt="" loading="lazy"></figure>
<h1 id="2-简单入门">2. 简单入门</h1>
<h2 id="21-ioc">2.1 IOC</h2>
<blockquote>
<p>IOC称之为控制反转，大致的意思是将项目中有自己来维护的对象创建由Spring进行来创建管理，自己维护时是用什么创建什么，现在是需要什么就直接从容器中拿什么。</p>
</blockquote>
<p>示例：</p>
<ol>
<li>创建项目，添加核心依赖：</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>创建需要管理类：</li>
</ol>
<pre><code class="language-java">public interface UserDao {
    void save();
}

public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println(&quot;UserDao save run&quot;);
    }
}

public interface UserService {
    void add();
}

public class UserServiceImpl implements UserService {

    private UserDao userDao = new UserDaoImpl();

    public void add() {
        userDao.save();
        System.out.println(&quot;UserService add run...&quot;);
    }
}
</code></pre>
<ol start="3">
<li>创建配置文件：</li>
</ol>
<p>application.xml</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>使用容器获得类：</li>
</ol>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        UserService userService = (UserService) context.getBean(&quot;userService&quot;);
        userService.add();
    }
}
</code></pre>
<h2 id="22-di">2.2 DI</h2>
<blockquote>
<p>类之间可能存在依赖，DI技术会把需要的依赖一并纳入容器管理。</p>
</blockquote>
<ol>
<li>修改<code>UserServiceImpl</code>类</li>
</ol>
<pre><code class="language-java">public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void add() {
        userDao.save();
        System.out.println(&quot;UserService add run...&quot;);
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
</code></pre>
<ol start="2">
<li>配置依赖关系</li>
</ol>
<pre><code class="language-xml">&lt;beans&gt;

    &lt;!--配置需要管理的类
        id：唯一标识
        class：类的全路径名
    --&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.dao.impl.UserDaoImpl&quot;/&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot;&gt;
        &lt;!--设置属性
            name：属性名称
            ref：关联的类（其他配置类id）
        --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="3">
<li>调用</li>
</ol>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        UserService userService = (UserService) context.getBean(&quot;userService&quot;);
        userService.add();
    }
}
</code></pre>
<h1 id="3-ioc和bean">3. IOC和Bean</h1>
<blockquote>
<p>在Spring中每个类对象被称为Bean，Bean通过一系列的属性配置，容器可以通过一些列配置信息进行管理。</p>
</blockquote>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean .../&gt;
    &lt;bean .../&gt;
    ...
&lt;/beans&gt;
</code></pre>
<h2 id="31-基础属性">3.1 基础属性</h2>
<h3 id="311-id">3.1.1 id</h3>
<blockquote>
<p>bean的唯一标识，主要用于bean查找。</p>
</blockquote>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;userDao&quot; .../&gt;
    &lt;bean id=&quot;userService&quot; .../&gt;
    ...
&lt;/beans&gt;
</code></pre>
<h3 id="312-class">3.1.2 class</h3>
<blockquote>
<p>bean需要实例化类的全路径名</p>
</blockquote>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.dao.impl.UserDaoImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot; /&gt;
    ...
&lt;/beans&gt;
</code></pre>
<h3 id="313-name">3.1.3 name</h3>
<blockquote>
<p>为bean起的别名，引用bean也可以通过name中名称完成，多个name名称可以通过逗号（,）分号（;）和空格来实现</p>
</blockquote>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.dao.impl.UserDaoImpl&quot; name=&quot;dao ud&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot; name=&quot;service us&quot;&gt;
        &lt;!--可以引用别名--&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;/&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;
</code></pre>
<h3 id="314-scope">3.1.4 scope</h3>
<blockquote>
<p>bean的作用范围，表示bean是单例还是多例。可选值为singleton和prototype。bean默认是单例的，所以可能出现线程安全问题。所以容器中管理的对象一般<br>
为无状态类，此类不存储数据。例如表现层，服务层，数据层，工具类。</p>
</blockquote>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;!--单例对象--&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.dao.impl.UserDaoImpl&quot; name=&quot;dao ud&quot; scope=&quot;singleton&quot;/&gt;
    &lt;!--多例对象--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot; name=&quot;service us&quot; scope=&quot;prototype&quot;&gt;
        &lt;!--可以引用别名--&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;dao&quot;/&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;
</code></pre>
<h2 id="32-bean实例化">3.2 bean实例化</h2>
<blockquote>
<p>容器通过配置就可以实例化类，它是通过构造方法进行类的创建，也可以通过bean配置来改变示例化方式。总结有三种方式来实例化构造方法、静态工厂和实例工厂。</p>
</blockquote>
<h3 id="321-构造方法">3.2.1 构造方法</h3>
<ol>
<li>准备的类</li>
</ol>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    // 构造函数权限为private，Spring还是可以实力化对象的
    public UserDaoImpl() {
        System.out.println(&quot;UserDaoImpl init...&quot;);
    }

    public void save() {
        System.out.println(&quot;UserDao save run&quot;);
    }
}
</code></pre>
<ol start="2">
<li>配置bean</li>
</ol>
<p><code>&lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.dao.impl.UserDaoImpl&quot;/&gt;</code></p>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        UserDao userDao = (UserDao) context.getBean(&quot;userDao&quot;);
        userDao.save();
    }
}
</code></pre>
<p><strong><em>通过以上控制台显示可以看出是调用构造函数，但是当我们把构造函数权限变成私private有也是可以实例化对象的。</em></strong><br>
这是因为Spring是通过反射来实现初始化的。但是类必须有无参构造函数，否则无法实例化。</p>
<h3 id="322-静态工厂">3.2.2 静态工厂</h3>
<blockquote>
<p>用工厂类来实现类的实例化</p>
</blockquote>
<pre><code class="language-java">public class UserDaoFactory {
    public static UserDao userDao() {
        // 实例化前一些必须操作
        System.out.println(&quot;init UserDao pre work...&quot;);
        return new UserDaoImpl();
    }
}
</code></pre>
<p>配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.tool.UserDaoFactory&quot; factory-method=&quot;userDao&quot;/&gt;
</code></pre>
<h3 id="323-实例化工厂">3.2.3 实例化工厂</h3>
<blockquote>
<p>通过工厂实例化bean与静态工厂不同的是需要先实例化工厂才可以使用。</p>
</blockquote>
<ol>
<li>实例化工厂实现</li>
</ol>
<p>类：</p>
<pre><code class="language-java">public interface BookDao {
    void show();
}

public class BookDaoImpl implements BookDao {

    public BookDaoImpl() {
        System.out.println(&quot;BookDao init...&quot;);
    }

    public void show() {
        System.out.println(&quot;BookDao run...&quot;);
    }
}
</code></pre>
<p>工厂类：</p>
<pre><code class="language-java">public class BookDaoFactory {
    private BookDao bookDao() {
        return new BookDaoImpl();
    }
}
</code></pre>
<p>配置：</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;bookDaoFactory&quot; class=&quot;cn.fishland.tool.BookDaoFactory&quot;/&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;cn.fishland.dao.impl.BookDaoImpl&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;bookDao&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);
        bookDao.show();
    }
}
</code></pre>
<ol start="2">
<li>实现FactoryBean创建实例化工厂</li>
</ol>
<p>创建工程类：</p>
<pre><code class="language-java">public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; {
    /** 获得实例化对象 */
    public BookDao getObject() throws Exception {
        return new BookDaoImpl();
    }

    /** 实例化对象类型 */
    public Class&lt;?&gt; getObjectType() {
        return null;
    }

    /** 是否为单例 */
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<p>配置文件：</p>
<pre><code class="language-xml">&lt;!--如此简单--&gt;
&lt;bean id=&quot;bookDaoBean&quot; class=&quot;cn.fishland.tool.BookDaoFactoryBean&quot;/&gt;
</code></pre>
<h2 id="33-bean生命周期">3.3 bean生命周期</h2>
<blockquote>
<p>生命周期即bean从创建到销毁的过程，在整个过程都干了什么事（执行了哪些方法以便于我们自己实现来进行修改）。</p>
</blockquote>
<ol>
<li>简单实现</li>
</ol>
<p>类：</p>
<pre><code class="language-java">public interface MenuDao {
    void save();
}

public class MenuDaoImpl implements MenuDao {
    public MenuDaoImpl() {
        System.out.println(&quot;MenuDaoImpl construct...&quot;);
    }

    public void save() {
        System.out.println(&quot;MenuDaoImpl save run...&quot;);
    }

    public void init() {
        System.out.println(&quot;MenuDaoImpl init...&quot;);
    }

    public void destory() {
        System.out.println(&quot;MenuDaoImpl destory...&quot;);
    }
}
</code></pre>
<p>配置：<code>&lt;bean id=&quot;menuDao&quot; class=&quot;cn.fishland.dao.impl.MenuDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;</code></p>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        MenuDao menuDao = (MenuDao) context.getBean(&quot;menuDao&quot;);
        menuDao.save();
        // 关闭容器
        context.close();
    }
}
</code></pre>
<blockquote>
<p>执行顺序构造、init、destory</p>
</blockquote>
<ol start="2">
<li>通过实现接口简化配置</li>
</ol>
<blockquote>
<p>实现接口InitializingBean完成afterPropertiesSet方法，为bean的init-method。实现接口DisposableBean完成destroy方法，为bean的destroy-method</p>
</blockquote>
<p>类：</p>
<pre><code class="language-java">public class MenuDaoImpl implements MenuDao, InitializingBean, DisposableBean {
    public MenuDaoImpl() {
        System.out.println(&quot;MenuDaoImpl construct...&quot;);
    }

    public void save() {
        System.out.println(&quot;MenuDaoImpl save run...&quot;);
    }

    /** destroy方法 */
    public void destroy() throws Exception {
        System.out.println(&quot;MenuDaoImpl destroy...&quot;);
    }

    /** init方法 */
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;MenuDaoImpl afterPropertiesSet...&quot;);
    }
}
</code></pre>
<p>配置：</p>
<p><code>&lt;bean id=&quot;menuDao&quot; class=&quot;cn.fishland.dao.impl.MenuDaoImpl&quot;/&gt;</code></p>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        MenuDao menuDao = (MenuDao) context.getBean(&quot;menuDao&quot;);
        menuDao.save();
        // 关闭容器
        context.close();
    }
}
</code></pre>
<p><strong>总结：</strong> bean的生命周期</p>
<ol>
<li>创建对象</li>
<li>调用构造</li>
<li>执行setter</li>
<li>执行bean的init</li>
<li>使用bean执行业务方法</li>
<li>关闭销毁执行bean销毁方法</li>
</ol>
<h1 id="4-di">4. DI</h1>
<blockquote>
<p>DI称为依赖注入，就是通过配置将类属性进行设置。依赖注入分为两种setter和构造方法，注入的内容为引用类型和基础数据类型。</p>
</blockquote>
<h2 id="41-setter">4.1 setter</h2>
<h3 id="421-注入引用数据类型">4.2.1 注入引用数据类型</h3>
<p>类：</p>
<pre><code class="language-java">public interface UserDao {
    void save();
}

public class UserDaoImpl implements UserDao {
    public UserDaoImpl() {
        System.out.println(&quot;UserDaoImpl init...&quot;);
    }

    public void save() {
        System.out.println(&quot;UserDao save run&quot;);
    }
}

public interface UserService {
    void add();
}

public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void add() {
        userDao.save();
        System.out.println(&quot;UserService add run...&quot;);
    }

    // 需要添加属性set方法
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
</code></pre>
<p>配置信息：</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.tool.UserDaoFactory&quot; factory-method=&quot;userDao&quot;/&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot;&gt;
        &lt;!--设置属性
            name：属性名称
            ref：关联的类（其他配置类id）
        --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        UserService userService = (UserService) context.getBean(&quot;userService&quot;);
        userService.add();
        // 关闭容器
        context.close();
    }
}
</code></pre>
<h3 id="421-注入基础数据类型">4.2.1 注入基础数据类型</h3>
<p>类：</p>
<pre><code class="language-java">public interface TagDao {
    void show();
}

public class TagDaoImpl implements TagDao {
    private String name;
    private String flag;

    public void show() {
        System.out.println(&quot;TagDaoImpl show... name=&quot; + name + &quot; flag=&quot; + flag);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setFlag(String flag) {
        this.flag = flag;
    }
}
</code></pre>
<p>配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;tagDao&quot; class=&quot;cn.fishland.dao.impl.TagDaoImpl&quot;&gt;
    &lt;!--
        name：需要注入的属性名称
        value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
    --&gt;
    &lt;property name=&quot;name&quot; value=&quot;fish&quot;/&gt;
    &lt;property name=&quot;flag&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        TagDao tagDao = (TagDao) context.getBean(&quot;tagDao&quot;);
        tagDao.show();
        // 关闭容器
        context.close();
    }
}
</code></pre>
<h2 id="42-构造注入">4.2 构造注入</h2>
<h3 id="421-引用类型注入">4.2.1 引用类型注入</h3>
<p>类：</p>
<pre><code class="language-java">public interface TagService {
    void add();
}

public class TagServiceImpl implements TagService {

    private TagDao tagDao;

    public TagServiceImpl(TagDao tagDao) {
        this.tagDao = tagDao;
    }

    public void add() {
        tagDao.show();
        System.out.println(&quot;TagServiceImpl add...&quot;);
    }
}
</code></pre>
<p>配置：</p>
<pre><code class="language-xml">&lt;bean&gt;
    &lt;bean id=&quot;tagDao&quot; class=&quot;cn.fishland.dao.impl.TagDaoImpl&quot;&gt;
        &lt;!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;fish&quot;/&gt;
        &lt;property name=&quot;flag&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;tagService&quot; class=&quot;cn.fishland.service.impl.TagServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;tagDao&quot; ref=&quot;tagDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        TagService tagService = (TagService) context.getBean(&quot;tagService&quot;);
        tagService.add();
        // 关闭容器
        context.close();
    }
}
</code></pre>
<h3 id="422-基础数据类型">4.2.2 基础数据类型</h3>
<pre><code class="language-java">public class TagServiceImpl implements TagService {

    private TagDao tagDao;
    private String name;
    private Integer flag;

    public TagServiceImpl(TagDao tagDao) {
        this.tagDao = tagDao;
    }

    public TagServiceImpl(TagDao tagDao, String name, Integer flag) {
        this.tagDao = tagDao;
        this.name = name;
        this.flag = flag;
    }

    public void add() {
        tagDao.show();
        System.out.println(&quot;TagServiceImpl add...&quot;);
        System.out.println(&quot;TagServiceImpl name=&quot; + name);
        System.out.println(&quot;TagServiceImpl flag=&quot; + flag);
    }
}
</code></pre>
<p>配置：方式一</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;tagDao&quot; class=&quot;cn.fishland.dao.impl.TagDaoImpl&quot;&gt;
        &lt;!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;fish&quot;/&gt;
        &lt;property name=&quot;flag&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;tagService&quot; class=&quot;cn.fishland.service.impl.TagServiceImpl&quot;&gt;
        &lt;!--
            name:为形参的名称
        --&gt;
        &lt;constructor-arg name=&quot;tagDao&quot; ref=&quot;tagDao&quot;/&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;fish&quot;/&gt;
        &lt;constructor-arg name=&quot;flag&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>配置：方式二，主要输解决构造方法形参名称改变导致的一些列问题</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;tagDao&quot; class=&quot;cn.fishland.dao.impl.TagDaoImpl&quot;&gt;
        &lt;!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;fish&quot;/&gt;
        &lt;property name=&quot;flag&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;tagService&quot; class=&quot;cn.fishland.service.impl.TagServiceImpl&quot;&gt;
        &lt;!--
            type：为形参的数据类型，当存在相同数据类型就会出现问题
        --&gt;
        &lt;constructor-arg type=&quot;cn.fishland.dao.TagDao&quot; ref=&quot;tagDao&quot;/&gt;
        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;fish&quot;/&gt;
        &lt;constructor-arg type=&quot;java.lang.Integer&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>配置：方式三，解耦又可以避免相同类型问题</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;tagDao&quot; class=&quot;cn.fishland.dao.impl.TagDaoImpl&quot;&gt;
        &lt;!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;fish&quot;/&gt;
        &lt;property name=&quot;flag&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--
        index：形参的位置，从0开始
    --&gt;
    &lt;bean id=&quot;tagService&quot; class=&quot;cn.fishland.service.impl.TagServiceImpl&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;tagDao&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;fish&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot; value=&quot;1&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="43-自动装配">4.3 自动装配</h2>
<blockquote>
<p>前面两种方式都较麻烦，需要大量的配置文件，Spring还提供了自动装配设置，更为简单。IOC容器会根据一些条件自动在容器中寻找符合条件的依赖bean。<br>
装配的条件为按照类型、按照名称。</p>
</blockquote>
<ol>
<li>按类型注入</li>
</ol>
<p><strong>自动装配必须条件：</strong></p>
<ol>
<li>被注入类必须在容器管理中</li>
<li>注入属性需要有setter方法</li>
<li>容器中存在多个相同类型按照类型注入就会失败</li>
</ol>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    public UserDaoImpl() {
        System.out.println(&quot;UserDaoImpl init...&quot;);
    }

    public void save() {
        System.out.println(&quot;UserDao save run&quot;);
    }
}

public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void add() {
        userDao.save();
        System.out.println(&quot;UserService add run...&quot;);
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean class=&quot;cn.fishland.tool.UserDaoFactory&quot; factory-method=&quot;userDao&quot;/&gt;
    &lt;!--
        autowire；开启自动装配，byType表示根据类型装配
    --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<ol start="2">
<li>按名称注入</li>
</ol>
<blockquote>
<p>存在一个问题，当容器存在多个相同类型，就会导致装配失败，这时可以使用根据名称装配。按照名称注入如果容器找不到对应的类就会注入null</p>
</blockquote>
<p>名称：指的是注入setter方法去掉set后首字母小写名称，按照默认set规则，最后的结果就是属性名称。</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.fishland.tool.UserDaoFactory&quot; factory-method=&quot;userDao&quot;/&gt;
    &lt;!--
        byName：开启根据名称注入
    --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.fishland.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p><em><strong>总结：</strong></em></p>
<ol>
<li>自动装配适用于引用类型，不适用基础数据类型</li>
<li>按照类型装配需要确保容器中只有一个类型的bean</li>
<li>按照名称注入耦合较大</li>
<li>自动装配优先级低于setter和构造方法配置注入，同时存在自动装配失效</li>
</ol>
<h2 id="44-集合注入">4.4 集合注入</h2>
<pre><code class="language-java">public class CollectionDaoImpl implements CollectionDao {

    private int[] array;
    private List&lt;String&gt; list;
    private Set&lt;String&gt; set;
    private Map&lt;String, String&gt; map;
    private Properties properties;

    public void showData() {
        System.out.println(&quot;CollectionDaoImpl showData...&quot;);
        System.out.println(&quot;CollectionDaoImpl array=&quot; + Arrays.toString(array));
        System.out.println(&quot;CollectionDaoImpl list=&quot; + list);
        System.out.println(&quot;CollectionDaoImpl set=&quot; + set);
        System.out.println(&quot;CollectionDaoImpl map=&quot; + map);
        System.out.println(&quot;CollectionDaoImpl properties=&quot; + properties);

    }

    public void setArray(int[] array) {
        this.array = array;
    }

    public void setList(List&lt;String&gt; list) {
        this.list = list;
    }

    public void setSet(Set&lt;String&gt; set) {
        this.set = set;
    }

    public void setMap(Map&lt;String, String&gt; map) {
        this.map = map;
    }

    public void setProperties(Properties properties) {
        this.properties = properties;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;collectionDao&quot; class=&quot;cn.fishland.dao.impl.CollectionDaoImpl&quot;&gt;
    &lt;property name=&quot;array&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;3&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;list&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;itcast&lt;/value&gt;
            &lt;value&gt;itheima&lt;/value&gt;
            &lt;value&gt;boxuegu&lt;/value&gt;
            &lt;value&gt;chuanzhihui&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;set&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;itcast&lt;/value&gt;
            &lt;value&gt;itheima&lt;/value&gt;
            &lt;value&gt;boxuegu&lt;/value&gt;
            &lt;value&gt;boxuegu&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;country&quot; value=&quot;china&quot;/&gt;
            &lt;entry key=&quot;province&quot; value=&quot;henan&quot;/&gt;
            &lt;entry key=&quot;city&quot; value=&quot;kaifeng&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;country&quot;&gt;china&lt;/prop&gt;
            &lt;prop key=&quot;province&quot;&gt;henan&lt;/prop&gt;
            &lt;prop key=&quot;city&quot;&gt;kaifeng&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h1 id="5-配置第三方bean">5. 配置第三方Bean</h1>
<p>配置Druid数据库连接池:</p>
<ol>
<li>引依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.2.15&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.30&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>配置</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:33060/BookManager&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        DataSource dataSource = (DataSource) context.getBean(&quot;dataSource&quot;);
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        // 关闭容器
        context.close();
    }
}
</code></pre>
<p>配置C3p0数据库连接池:</p>
<p>配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dataSourceC3p0&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:33060/BookManager&quot;/&gt;
    &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;maxPoolSize&quot; value=&quot;1000&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h1 id="6-加载properties文件">6. 加载properties文件</h1>
<ol>
<li>添加properties文件</li>
</ol>
<p>jdbc.properties</p>
<pre><code class="language-properties">jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:33060/BookManager
jdbc.username=root
jdbc.password=root
</code></pre>
<ol start="2">
<li>添加context命名空间</li>
</ol>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            &lt;!--新增--&gt;
            http://www.springframework.org/schema/context
            &lt;!--新增--&gt;
            http://www.springframework.org/schema/context/spring-context.xsd&quot;
        &lt;!--新增--&gt;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;&gt;
    
&lt;/beans&gt;
</code></pre>
<ol start="3">
<li>配置添加properties文件</li>
</ol>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;!--加载本地文件--&gt;
    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>引用properties属性</li>
</ol>
<pre><code class="language-xml">&lt;!--使用${}来获得内容--&gt;
&lt;bean id=&quot;dataSourceC3p0&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
    &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;property name=&quot;maxPoolSize&quot; value=&quot;1000&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>测试</li>
</ol>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        DataSource dataSource = (DataSource) context.getBean(&quot;dataSourceC3p0&quot;);
        System.out.println(dataSource);
        // 关闭容器
        context.close();
    }
}
</code></pre>
<p><em><strong>注意：</strong></em></p>
<ol>
<li>本地的username与环境变量冲突</li>
</ol>
<p>在加载jdbc.properties文件的时候，也会加载系统环境变量。本地与系统发生冲突后，系统优先。</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        /*此方法可以查看系统环境变量*/
        Map&lt;String, String&gt; env = System.getenv();
        System.out.println(env);
    }
}
</code></pre>
<p>可以配置<code>system-properties-mode=&quot;NEVER&quot;</code>表示不加载系统环境变量</p>
<ol start="2">
<li>加载多个文件</li>
</ol>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;!--
        在location中配置多个文件名，中间用逗号隔开
    --&gt;
    &lt;context:property-placeholder location=&quot;jdbc.properties,jdbc2.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;
    &lt;!--
        *.properties：表示所有以properties结尾的文件都会被加载
    --&gt;
    &lt;context:property-placeholder location=&quot;*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;
    &lt;!--
        classpath:*.properties：项目根目录下所有properties文件都会被加载
    --&gt;
    &lt;context:property-placeholder location=&quot;classpath:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;
    &lt;!--
        classpath*:*.properties：项目加项目依赖所有的properties文件
    --&gt;
    &lt;context:property-placeholder location=&quot;classpath*:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="7-核心容器">7. 核心容器</h1>
<h2 id="71-容器创建">7.1 容器创建</h2>
<blockquote>
<p>容器主要有两种：ClassPathXmlApplicationContext和FileSystemXmlApplicationContext</p>
</blockquote>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        /*
         * 类翻译过来的意思就是类路径下XML配置文件，所以参数就是类路径下xml文件
         * */
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);

        /*
         * 文件系统下的XML配置文件，配置文件在项目的文件系统下
         * */
        FileSystemXmlApplicationContext context1 = new FileSystemXmlApplicationContext(&quot;D:\\XXX\\XX\\X\\application.xml&quot;);
    }
}
</code></pre>
<h2 id="72-bean获得">7.2 Bean获得</h2>
<blockquote>
<p>获得bean有三种方式</p>
</blockquote>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        // 通过bean的id获得
        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);
        // 通过名称获得，并且给出结果的类型，免除强制类型转换       
        BookDao bookDao = ctx.getBean(&quot;bookDao&quot;, BookDao.class);
        // 直接通过类型获得，这种方法存在一些局限性，确保容器中只有一个这种类型实例
        BookDao bookDao = ctx.getBean(BookDao.class);
    }
}
</code></pre>
<h2 id="73-beanfactory">7.3 BeanFactory</h2>
<p>创建BeanFactory：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        XmlBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));
        CollectionDao collectionDao = beanFactory.getBean(&quot;collectionDao&quot;, CollectionDao.class);
        collectionDao.showData();
    }
}
</code></pre>
<p>ApplicationContext和BeanFactory区别：</p>
<ol>
<li>BeanFactory是懒加载，使用时才会加载</li>
<li>ApplicationContext支持懒加载，但是默认是容器创建就会加载bean</li>
</ol>
<p>ApplicationContext实现懒加载：</p>
<pre><code class="language-xml">&lt;!--
    lazy-init:true开启加载，false为不开启，default默认
--&gt;
&lt;bean id=&quot;menuDao&quot; class=&quot;cn.fishland.dao.impl.MenuDaoImpl&quot; lazy-init=&quot;true&quot;/&gt;
</code></pre>
<h1 id="8-注解开发">8. 注解开发</h1>
<h2 id="81-注解定义bean">8.1 注解定义bean</h2>
<p>类：</p>
<pre><code class="language-java">public interface RoleService {
    void add();
}

@Component(&quot;roleService&quot;)
public class RoleServiceImpl implements RoleService {
    public void add() {
        System.out.println(&quot;RoleServiceImpl add...&quot;);
    }
}
</code></pre>
<p>配置：</p>
<pre><code class="language-xml">&lt;!--
    开启注解组件扫描
    base-package：当前包及其子包的类
--&gt;
&lt;context:component-scan base-package=&quot;cn.fishland&quot;/&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        RoleService bean = context.getBean(RoleService.class);
        bean.add();
    }
}
</code></pre>
<blockquote>
<p>@Component(&quot;roleService&quot;)注解表示当前类为bean，当spring扫描到类带此注解就会将类加载到容器中。@Component注解后面也可以什么都不加，这时<br>
此类的名称就是类首字母小写的名称。<strong>@Component注解不可以放在接口类上</strong>，接口无法直接创建。</p>
</blockquote>
<p>@Component衍生注解：同@Component同样效果</p>
<ol>
<li>@Controller：表现层</li>
<li>@Service：服务层</li>
<li>@Repository：数据层</li>
</ol>
<h2 id="82-存注解开发">8.2 存注解开发</h2>
<blockquote>
<p>通过以上的示例，发现使用Spring还是挺麻烦，xml文件配置较为繁琐。Spring在3.0后就支持存注解开发了，去掉xml配置文件直接用类来进行配置。</p>
</blockquote>
<p>配置类：</p>
<pre><code class="language-java">// 标识当前类为配置类，取代xml配置文件
@Configuration
// 开启包扫描
@ComponentScan(&quot;cn.fishland&quot;)
public class AppConfig {
}
</code></pre>
<p>bean类：</p>
<pre><code class="language-java">public interface RoleService {
    void add();
}

@Component(&quot;roleService&quot;)
public class RoleServiceImpl implements RoleService {
    public void add() {
        System.out.println(&quot;RoleServiceImpl add...&quot;);
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException {
        // 使用AnnotationConfigApplicationContext加载配置类
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        RoleService bean = context.getBean(RoleService.class);
        bean.add();
    }
}
</code></pre>
<blockquote>
<p>从此处开始Spring的使用就简洁很多</p>
</blockquote>
<h2 id="83-注解下bean作用范围和生命周期">8.3 注解下bean作用范围和生命周期</h2>
<p>bean类：</p>
<pre><code class="language-java">@Component(&quot;roleService&quot;)
//@Scope(&quot;prototype&quot;) 配置bean范围注解，表示多例
@Scope(&quot;singleton&quot;) // 配置bean范围，表示单例，默认值，不配也行
public class RoleServiceImpl implements RoleService {
    public void add() {
        System.out.println(&quot;RoleServiceImpl add...&quot;);
    }

    // init注解，表示当前方法为init方法
    @PostConstruct
    public void init() {
        System.out.println(&quot;init ...&quot;);
    }

    // destroy注解，当前方法为destroy方法
    @PreDestroy
    public void destroy() {
        System.out.println(&quot;destroy ...&quot;);
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException, InterruptedException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        RoleService bean1 = context.getBean(RoleService.class);
        System.out.println(bean1);
        context.close();
    }
}
</code></pre>
<p>注解和xml配置关系：</p>
<figure data-type="image" tabindex="2"><img src="../../../img/spring1.png" alt="" loading="lazy"></figure>
<h2 id="84-注解依赖注入">8.4 注解依赖注入</h2>
<h3 id="841-自动注入">8.4.1 自动注入</h3>
<pre><code class="language-java">// 加入容器
@Repository
public class RoleDaoImpl implements RoleDao {
    public void insert() {
        System.out.println(&quot;RoleDaoImpl run...&quot;);
    }
}

@Component
public class RoleServiceImpl implements RoleService {

    // 根据类型自动注入
    @Autowired
    private RoleDao roleDao;

    public void add() {
        roleDao.insert();
        System.out.println(&quot;RoleServiceImpl add...&quot;);
    }

}

// 测试
public class Application {
    public static void main(String[] args) throws Exception {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        RoleService bean1 = context.getBean(RoleService.class);
        bean1.add();
        context.close();
    }
}
</code></pre>
<h3 id="842-按照名称注入">8.4.2. 按照名称注入</h3>
<blockquote>
<p>当容器中出现多个同类型实例时就需要按照名称注入</p>
</blockquote>
<pre><code class="language-java">@Repository
public class RoleDaoImpl implements RoleDao {
    public void insert() {
        System.out.println(&quot;RoleDaoImpl run...&quot;);
    }
}

@Repository(&quot;roleDaoImpl1&quot;)
public class RoleDaoImpl1 implements RoleDao {
    public void insert() {
        System.out.println(&quot;RoleDaoImpl1 run...&quot;);
    }
}

@Service(&quot;roleService&quot;)
public class RoleServiceImpl implements RoleService {

    @Autowired
    // 根据名称注入，不能单独使用必须配合Autowired使用
    @Qualifier(&quot;roleDaoImpl1&quot;)
    private RoleDao roleDao;

    public void add() {
        roleDao.insert();
        System.out.println(&quot;RoleServiceImpl add...&quot;);
    }
}

</code></pre>
<p>总结：</p>
<ol>
<li>@Autowired根类型装配，出现多个相同类型时，就会使用属性变量名进行名称装配，再找不到就会抛异常。</li>
<li>@Qualifier不能单独使用，需要配合@Autowried使用。</li>
</ol>
<h3 id="843-简单数据类型注入">8.4.3 简单数据类型注入</h3>
<pre><code class="language-java">@Repository
public class DataDaoImpl implements DataDao {

    @Value(&quot;fish&quot;)
    private String name;

    public void shoeData() {
        System.out.println(&quot;DataDaoImpl name=&quot; + name);
    }
}
</code></pre>
<p>@Value配合properties使用</p>
<p>加载配置文件</p>
<pre><code class="language-java">@Configuration
// 加载配置文件
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@ComponentScan(&quot;cn.fishland&quot;)
public class AppConfig {
}
</code></pre>
<p>使用配置文件中数据：</p>
<pre><code class="language-java">@Repository
public class DataDaoImpl implements DataDao {

    @Value(&quot;fish&quot;)
    private String name;

    // 使用配置文件中数据
    @Value(&quot;${jdbc.url}&quot;)
    private String url;

    public void shoeData() {
        System.out.println(&quot;DataDaoImpl name=&quot; + name);
        System.out.println(&quot;DataDaoImpl url=&quot; + url);
    }
}
</code></pre>
<blockquote>
<p>家在多个配置文件@PropertySource({&quot;jdbc1.properties&quot;,&quot;jdbc2.properties&quot;})</p>
</blockquote>
<h3 id="844-注入第三方bean">8.4.4 注入第三方bean</h3>
<p>新建配置类：</p>
<pre><code class="language-java">
// @Configuration 这个注解可以加也可以在另一个配置中使用@Import配置，示例如下
public class JdbcConfig {

    @Value(&quot;${jdbc.driver}&quot;)
    private String driver;

    @Value(&quot;${jdbc.url}&quot;)
    private String url;

    @Value(&quot;${jdbc.username}&quot;)
    private String username;

    @Value(&quot;${jdbc.password}&quot;)
    private String password;

    // 在方法上直接添加@Bean注解即可
    @Bean
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}

// 主配置类
@Configuration
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@ComponentScan(&quot;cn.fishland&quot;)
// 添加另一个配置类
@Import({JdbcConfig.class})
public class AppConfig {
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws SQLException, InterruptedException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        DataSource dataSource = context.getBean(DataSource.class);
        System.out.println(dataSource.getConnection());
        context.close();
    }
}
</code></pre>
<blockquote>
<p>当@Bean配置的类需要注入其他bean怎么办了，Spring给出的解决办法是，直接设置形参就像，Spring会自动根据形参进行自动注入。示例如下：</p>
</blockquote>
<pre><code class="language-java">public class JdbcConfig {

    @Value(&quot;${jdbc.driver}&quot;)
    private String driver;

    @Value(&quot;${jdbc.url}&quot;)
    private String url;

    @Value(&quot;${jdbc.username}&quot;)
    private String username;

    @Value(&quot;${jdbc.password}&quot;)
    private String password;

    // 形参中直接设置即可，容器会自动根据类型进行注入，爽^_^
    @Bean
    public DataSource dataSource(DataDao dataDao) {
        dataDao.shoeData();
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
</code></pre>
<h1 id="9-第三方框架整合">9. 第三方框架整合</h1>
<h2 id="91-mybatis整合">9.1 Mybatis整合</h2>
<p>添加依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.2.15&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.30&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;!--Spring操作数据库需要该jar包--&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;!--Spring与Mybatis整合的jar包 这个jar包mybatis在前面，是Mybatis提供的 --&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;1.3.0&lt;/version&gt;
    &lt;/dependency&gt;    
&lt;/dependencies&gt;
</code></pre>
<p>创建数据源配置类：</p>
<pre><code class="language-java">public class JdbcConfig {

    @Value(&quot;${jdbc.driver}&quot;)
    private String driver;

    @Value(&quot;${jdbc.url}&quot;)
    private String url;

    @Value(&quot;${jdbc.username}&quot;)
    private String username;

    @Value(&quot;${jdbc.password}&quot;)
    private String password;

    @Bean
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
</code></pre>
<p>创建Mybatis配置类：</p>
<pre><code class="language-java">public class MybatisConfig {

    // 设置mybatis主要配置
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        // 配置别名
        sqlSessionFactoryBean.setTypeAliasesPackage(&quot;cn.fishland.pojo&quot;);
        // 配置数据源
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }

    // 配置mapper扫描包，mybatis需要加载的类
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();
        // 需要加载的类
        mapperScannerConfigurer.setBasePackage(&quot;cn.fishland.mapper&quot;);
        return mapperScannerConfigurer;
    }

}
</code></pre>
<p>主配置类：</p>
<pre><code class="language-java">// 表明为配置类
@Configuration
// 扫描组件包
@ComponentScan(&quot;cn.fishland&quot;)
// 导入配置文件
@PropertySource(&quot;classpath:jdbc.properties&quot;)
// 导入其他配置类
@Import({JdbcConfig.class, MybatisConfig.class})
public class AppConfig {
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) throws Exception {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        TagService bean = context.getBean(TagService.class);
        bean.findAll();
    }
}
</code></pre>
<h2 id="92-整合junit">9.2 整合Junit</h2>
<p>导入依赖：</p>
<pre><code class="language-xml">&lt;!--需要注意版本问题--&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>创建测试类运行即可：</p>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {AppConfig.class})
public class TagServiceTset {

    @Autowired
    private TagService tagService;

    @Test
    public void tagServiceTest() {
        tagService.findAll();
    }
}
</code></pre>
<h1 id="10-注解总结">10. 注解总结</h1>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>对比XML</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Component</td>
<td>标记当前类为bean，组件类，会被容器加载，衍生注解@Service，@Controller，@Repository</td>
<td>bean标签</td>
</tr>
<tr>
<td>@Configuration</td>
<td>当前类为配置类，代替application.xml配置文件</td>
<td>beans标签</td>
</tr>
<tr>
<td>@ComponentScan(&quot;cn.fishland&quot;)</td>
<td>放在配置类上，设置组件扫描包</td>
<td><code>&lt;context:component-scan base-package=&quot;cn.fishland&quot;/&gt;</code></td>
</tr>
<tr>
<td>@Scope(&quot;prototype&quot;)</td>
<td>配置bean的范围，值为prototype何singleton</td>
<td>bean标签scope属性</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>配置加载类的init方法</td>
<td>bean标签init-method属性</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>配置bean加载的destroy方法</td>
<td>bean标签destroy-method属性</td>
</tr>
<tr>
<td>@Autowired</td>
<td>根据类型自动注入类，同类型多个采用属性名查找，未找到抛异常</td>
<td>bean标签autowired属性</td>
</tr>
<tr>
<td>@Qualifier(&quot;roleDaoImpl1&quot;)</td>
<td>根据名称注入bean，需要同@Autowired注解一同使用</td>
<td>bean标签autowired属性的byName值</td>
</tr>
<tr>
<td>@Value(&quot;xx&quot;)</td>
<td>注入普通值到属性中，也可以引用外部配置值，例如：@Value(&quot;${jdbc.url}&quot;)</td>
<td><code>&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:33060/BookManager&quot;/&gt;</code></td>
</tr>
<tr>
<td>@PropertySource(&quot;classpath:jdbc.properties&quot;)</td>
<td>加载外部properties文件，classpath表示项目根目录开始</td>
<td><code>&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;</code></td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，会将返回值加入容器中，名称为方法名</td>
<td>bean标签</td>
</tr>
<tr>
<td>@Import({JdbcConfig.class})</td>
<td>用在配置类上，加载其他配置类</td>
<td></td>
</tr>
<tr>
<td>@RunWith(SpringJUnit4ClassRunner.class)</td>
<td>测试类注解</td>
<td></td>
</tr>
<tr>
<td>@ContextConfiguration(classes = {AppConfig.class})</td>
<td>测试类加载的配置类</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis基础教程]]></title>
        <id>https://stackyu.github.io/post/mybatis/</id>
        <link href="https://stackyu.github.io/post/mybatis/">
        </link>
        <updated>2023-01-03T07:42:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-核心配置文件">1. 核心配置文件</h1>
<blockquote>
<p>配置文件标签是需要按照指定顺序来设置的。</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--
        引入外部配置文件：
            resource：被引用文件名称
    --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;
    
    &lt;!--mybatis的全局配置信息--&gt;
    &lt;settings&gt;
        &lt;!--是否开启驼峰命名自动映射（默认关闭）--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    
    &lt;!--
        类型别名，不需要直接使用全类名，
        别名不区分大小写
    --&gt;
    &lt;typeAliases&gt;
        &lt;!--
            单独设置单个别名:
                type:需要设置的类
                alias：可不写，不写默认为类名
        --&gt;
        &lt;typeAlias type=&quot;cn.fishland.bookmanager.bean.pojo.Ebook&quot; alias=&quot;Ebook&quot;/&gt;
        &lt;!--设置包下所有别名--&gt;
        &lt;package name=&quot;cn.fishland.bookmanager.bean&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--
        配置数据源：
            default：使用的环境
    --&gt;
    &lt;environments default=&quot;developement&quot;&gt;
        &lt;!--
            单独数据源配置：
                id：数据源唯一标识
        --&gt;
        &lt;environment id=&quot;developement&quot;&gt;
            &lt;!--设置事务类型，JDBC表示后当前数据库--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!--
                dataSource：表示数据源设置
                    type：表示数据源类型，是否使用连接池
                        POOLED：使用连接池
                        UNPOOLED：表示不使用连接池
                        JNDI：使用上下文数据源
            --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!--
                    property：数据源相关配置
                        name：名称
                        value：值
                --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!--加载映射文件--&gt;
    &lt;mappers&gt;
        &lt;!--mapper xml--&gt;
        &lt;mapper resource=&quot;cn/fishland/bookmanager/mapper/CategoryMapper.xml&quot;/&gt;
        &lt;!--
            mapper interface class：以下条件为必须条件
                1. 需要mapper和接口目录结构相同，全类名相同
                2. mapper和接口类相同
        --&gt;
        &lt;package name=&quot;cn.fishland.bookmanager.mapper&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h1 id="2-接口和mapper的xml文件映射">2. 接口和mapper的xml文件映射</h1>
<ol>
<li>映射文件的namespace和接口全类名称相同</li>
<li>接口中的方法名和mapper中的id相同</li>
</ol>
<pre><code class="language-java">public interface UserMapper{
    int addUser(User user);
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;cn.fishland.mapper.UserMapper&quot;&gt;
    &lt;insert id=&quot;addUser&quot; parameterType=&quot;cn.fishland.bookmanager.bean.pojo.User&quot;&gt;
        insert into category(`name`) value (#{name});
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h1 id="3-mapper查询">3. mapper查询</h1>
<p>需要设置resultType或resultMap<br>
resultType：字段与数据库相同，直接使用bean<br>
resultMap：字段与数据库列不相同，需要单独处理</p>
<h1 id="4-获得参数值">4. 获得参数值</h1>
<ol>
<li><code>${}</code>:直接sql拼接</li>
<li><code>#{}</code>:占位符拼接</li>
</ol>
<h2 id="41-传入单个字面量值">4.1 传入单个字面量值</h2>
<p><code>User findById(Integer id)</code></p>
<p><code>${}</code>：需要添加双引号,值可以随便写，不受影响<br>
<code>#{}</code>:值随便写，不受影响，占位符</p>
<pre><code class="language-sql">select * from user where id = '${id}'；
select * from user where id = '1'；

select * from user where id = #{xxx}；
select * from user where id = '1'；
</code></pre>
<h2 id="42-传入多个字面量值">4.2 传入多个字面量值</h2>
<p><code>User findByPasswordAndName(String name, String password)</code></p>
<p><code>#{}</code>和<code>${}</code>：在获得多个值时，mybatis会自动将参数放在map集合中，两种方式存储，arg0，arg1...或param1,param2...两种方式都行，可混用</p>
<pre><code class="language-sql">select * from user where name = #{arg0} and password = #{param2}
</code></pre>
<h2 id="43-传入map集合参数">4.3 传入Map集合参数</h2>
<p><code>User findUserByMap(Map map)</code></p>
<p><code>#{}</code>和<code>${}</code>：在获得值时可以直接通过key获得值</p>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;name&quot;,&quot;fish&quot;);
map.put(&quot;password&quot;,&quot;fish123&quot;);
</code></pre>
<pre><code class="language-sql">select * from user where name = #{name} and password = #{password}
</code></pre>
<h2 id="44-传入实体类对象">4.4 传入实体类对象</h2>
<p><code>User findUser(User user)</code></p>
<p>与map参数相同，获得值只需要将<code>#{}</code>内部的值设置为属性值就可以了。通过get和set方法获得。</p>
<h2 id="45-命名参数param">4.5 命名参数@Param</h2>
<p>通过注解来指定参数名称</p>
<p><code>User findUserByNameAndPassword(@Param(&quot;name&quot;)String name, @Param(&quot;password&quot;)String password)</code></p>
<p><code>#{}</code>和<code>${}</code>使用时直接将name和password放在大括号中即可。也可以使用param1，param2...来使用。</p>
<h1 id="5-返回值">5. 返回值</h1>
<h2 id="51-返回多条记录">5.1 返回多条记录</h2>
<p>需要使用集合来接收</p>
<p><code>List&lt;User&gt; getAllUser()</code></p>
<h2 id="52-聚合查询">5.2 聚合查询</h2>
<p>统计数量</p>
<p><code>int count()</code></p>
<pre><code class="language-xml">&lt;select id=&quot;count&quot; resultMap=&quot;int&quot;&gt;
    select count(1) from user;
&lt;/select&gt;
</code></pre>
<blockquote>
<p>基础数据类型，mybatis提供了默认的类型别名</p>
</blockquote>
<h2 id="53-mapkey字段名">5.3 @Mapkey(&quot;字段名&quot;)</h2>
<p>使用map直接接收多条信息，指定map的key</p>
<pre><code class="language-java">@Mapkey(&quot;id&quot;)
Map&lt;Integer,Object&gt; getAllUser();
</code></pre>
<h1 id="6-模糊查询">6. 模糊查询</h1>
<ol>
<li>使用<code>${}</code>进行模糊查询</li>
</ol>
<pre><code class="language-sql">select * from user where name like '%${name}%'
</code></pre>
<ol start="2">
<li>使用<code>#{}</code>加count()函数进行拼接</li>
</ol>
<pre><code class="language-sql">select * from user where name like concat('%',#{name},'%');
</code></pre>
<ol start="3">
<li>使用<code>#{}</code>加双引号函数进行拼接</li>
</ol>
<pre><code class="language-sql">select * from user where name like &quot;%&quot;#{name}&quot;%&quot;;
</code></pre>
<h1 id="6-批量删除">6. 批量删除</h1>
<blockquote>
<p>使用in，将条件拼接后当参数传递sql中执行</p>
</blockquote>
<p><code>int deletes(@Param(&quot;ides&quot;)String ids)</code></p>
<pre><code class="language-sql">select * from user where id in (${ids})
</code></pre>
<p><strong>不能使用<code>#{}</code>只能使用<code>${}</code>这种才能进行删除，主要原因是<code>#{}</code>会自动添加引号</strong></p>
<h1 id="7-新增获得自增主键">7. 新增获得自增主键</h1>
<blockquote>
<p>新增后将自增主键放在参数中返回</p>
</blockquote>
<p><code>void insertUser(User user)</code></p>
<pre><code class="language-xml">&lt;!--
    useGeneratedKeys:设置sql是否使用自增主键
    keyProperty:将自增主键赋值到参数中的某个值或属性中
--&gt;
&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user(`name`) value (#{name});
&lt;/insert&gt;
</code></pre>
<h1 id="8-自定义映射">8. 自定义映射</h1>
<blockquote>
<p>表中的列名和类属性值不相同，或者多表查询结果问题，这时就需要使用resultMap，结果映射来完成。</p>
</blockquote>
<h2 id="81-通过别名处理列和属性不相同问题">8.1 通过别名处理列和属性不相同问题</h2>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;别名加代码片段（只用别名s也可以）&gt;--&gt;
&lt;sql id=&quot;userSql&quot;&gt;
        id, createTime, updateTime, status, sort, nick_name as nickName, name, password, icon, email,
company_name as companyName, sex, birthday, code, role
&lt;/sql&gt;
&lt;!--处理类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;select id=&quot;selectById&quot; resultType=&quot;User&quot;&gt;
    select
    &lt;include refid=&quot;userSql&quot;/&gt;
    from user
    where id = #{id}
    and status = 1;
&lt;/select&gt;
</code></pre>
<h2 id="82-通过mapunderscoretocamelcase全局配置">8.2 通过mapUnderscoreToCamelCase全局配置</h2>
<pre><code class="language-xml">&lt;!--mybatis的全局配置信息--&gt;
&lt;settings&gt;
    &lt;!--是否开启驼峰命名自动映射（默认关闭）--&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<h2 id="83-使用resultmap进行设置">8.3 使用resultMap进行设置</h2>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;resultMap id=&quot;userResult&quot; type=&quot;User&quot;&gt;
    &lt;result property=&quot;companyName&quot; column=&quot;company_name&quot;/&gt;
    &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot;/&gt;
&lt;/resultMap&gt;

&lt;!--
    resultMap：返回映射唯一id
--&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;userResult&quot;&gt;
    select *
    from user;
&lt;/select&gt;
</code></pre>
<h1 id="9-多表对应">9 多表对应</h1>
<p>准备内容：</p>
<pre><code class="language-java">class Emp {
    private Integer id;
    private String empName;
    private Integer age;
    private String sex;
    private String email;
    private Dept dept;
    //...
}

class Dept{
    private Integer did;
    private String name;
    //...
}
</code></pre>
<h2 id="91-多对一">9.1 多对一</h2>
<ol>
<li>通过resultMap和级联属性来解决映射问题</li>
</ol>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;resultMap id=&quot;empManyOne&quot; type=&quot;Emp&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;
    &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
    &lt;!--级联属性--&gt;
    &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;/&gt;
    &lt;!--级联属性--&gt;
    &lt;result property=&quot;dept.name&quot; column=&quot;name&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
    resultMap：返回映射唯一id
--&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;empManyOne&quot;&gt;
    select * from emp e left join dept d on e.did = d.did where e.id = #{id};
&lt;/select&gt;
</code></pre>
<ol start="2">
<li>通过association属性来进行设置</li>
</ol>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;resultMap id=&quot;empManyOne&quot; type=&quot;Emp&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;
    &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
    &lt;!--通过association来实现--&gt;
    &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;
        &lt;id property=&quot;did&quot; column=&quot;did&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
&lt;!--
    resultMap：返回映射唯一id
--&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;empManyOne&quot;&gt;
    select * from emp e left join dept d on e.did = d.did where e.id = #{id};
&lt;/select&gt;
</code></pre>
<ol start="3">
<li>分步查询</li>
</ol>
<pre><code class="language-xml">&lt;mapper namespace=&quot;DeptMapper&quot;&gt;
    &lt;select id=&quot;findByDid&quot; resultType=&quot;Dept&quot;&gt;
        select * from dept where did = #{did}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;resultMap id=&quot;empManyOne&quot; type=&quot;Emp&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;
    &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
    &lt;!--
        通过association的分步查询来实现：
            select:关联的是查询的语句（mapper唯一表示）
            column：查询条件的咧，当前哪个列作为条件传递给下一查询
            fetchType：有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。
    --&gt;
    &lt;association property=&quot;dept&quot; select=&quot;DeptMapper.findByDid&quot; column=&quot;did&quot; fetchType=&quot;lazy&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
    resultMap：返回映射唯一id
--&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;empManyOne&quot;&gt;
    select * from emp where id = #{id};
&lt;/select&gt;
</code></pre>
<p><strong>分布查询是可以懒加载，当不访问响应属性是不直接访问的。</strong><br>
懒加载是需要全局配置的：</p>
<pre><code class="language-xml">&lt;!--mybatis的全局配置信息--&gt;
&lt;settings&gt;
    &lt;!--是否开启懒加载（开启懒加载要确保aggressiveLazyLoading属性为false）--&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<h2 id="92-一对多">9.2 一对多</h2>
<p>准备内容：</p>
<pre><code class="language-java">class Emp {
    private Integer id;
    private String empName;
    private Integer age;
    private String sex;
    private String email;
    //...
}

class Dept{
    private Integer did;
    private String name;
    private List&lt;Emp&gt; emps;
    //...
}
</code></pre>
<ol>
<li>collection标签</li>
</ol>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;resultMap id=&quot;deptManyOne&quot; type=&quot;Dept&quot;&gt;
    &lt;id property=&quot;did&quot; column=&quot;did&quot; /&gt;
    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
    &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;
        &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;!--
    resultMap：返回映射唯一id
--&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;deptManyOne&quot;&gt;
    select * from dept d left join emp e on d.did = e.did where did = #{did};
&lt;/select&gt;
</code></pre>
<ol start="2">
<li>collection分步查询</li>
</ol>
<pre><code class="language-xml">&lt;mapper namespace=&quot;EmpMapper&quot;&gt;
    &lt;select id=&quot;getAllByDid&quot; resultType=&quot;Emp&quot;&gt;
        select * from emp where did = #{did}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="language-xml">&lt;!--解决类字段和表列不相同问题&lt;resultMap&gt;--&gt;
&lt;resultMap id=&quot;deptManyOne&quot; type=&quot;Dept&quot;&gt;
    &lt;id property=&quot;did&quot; column=&quot;did&quot; /&gt;
    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
    &lt;!--
        分布查询：也可以开启懒加载
    --&gt;
    &lt;collection property=&quot;emps&quot; select=&quot;EmpMapper.getAllByDid&quot; column=&quot;did&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--
    resultMap：返回映射唯一id
--&gt;
&lt;select id=&quot;selectAll&quot; resultMap=&quot;deptManyOne&quot;&gt;
    select * from dept where did = #{did};
&lt;/select&gt;
</code></pre>
<h1 id="10-动态sql">10. 动态sql</h1>
<blockquote>
<p>动态多条件查询就可以使用以下标签来实现</p>
</blockquote>
<h2 id="101-if标签">10.1 if标签</h2>
<pre><code class="language-xml">&lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt;
    select * from category where 1 = 1
    &lt;if test=&quot;name!=null and name!=''&quot;&gt;
        `name` = #{name}
    &lt;/if&gt;
    &lt;if test=&quot;status!=null&quot;&gt;
        `status` = #{status}
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<h2 id="102-where标签">10.2 where标签</h2>
<blockquote>
<p>当所有条件都不成立时，这时where关键字就多余，可以使用where来解决这一问题</p>
</blockquote>
<pre><code class="language-xml">&lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt;
    select * from category
    &lt;where&gt;
        &lt;if test=&quot;name!=null and name!=''&quot;&gt;
            `name` = #{name}
        &lt;/if&gt;
        &lt;if test=&quot;status!=null&quot;&gt;
            and `status` = #{status}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p><strong>where标签只能把if标签中多余的and或or去掉，放在结尾的and或or是去不掉的</strong></p>
<h2 id="103-trim标签">10.3 trim标签</h2>
<pre><code class="language-xml">&lt;!--
    prefix|suffix：将trim标签前|后添加指定内容
    prefixOverrides|suffixOverrides：将trim前后去掉指定内容
--&gt;
&lt;trim suffix=&quot;&quot; prefix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot; /&gt;
</code></pre>
<pre><code class="language-xml">&lt;!--
    trim：标签内内容全部成立也不会有效果
--&gt;
&lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt;
    select * from category
    &lt;trim  prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt;
        &lt;if test=&quot;name!=null and name!=''&quot;&gt;
            `name` = #{name} and
        &lt;/if&gt;
        &lt;if test=&quot;status!=null&quot;&gt;
            `status` = #{status} or
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;
</code></pre>
<h2 id="104-choosewhenotherwise">10.4 choose，when，otherwise</h2>
<pre><code class="language-xml">&lt;!--
    类似于if...else if...else if...else...
    
    choose:表示整个结构
    when：类似elseif
    otherwise：表示都不成立需要执行内容
--&gt;
&lt;select id=&quot;findByCategory&quot; resultType=&quot;Category&quot;&gt;
    select * from category
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;name!=null and name!=''&quot;&gt;
                `name` = #{name}
            &lt;/when&gt;
            &lt;when test=&quot;status!=null&quot;&gt;
                `status` = #{status}
            &lt;/when&gt;
            &lt;otherwise&gt;
                id = 1
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h2 id="105-foreach">10.5 foreach</h2>
<pre><code class="language-xml">&lt;!--
    foreach：循环（for）
        separator:分隔符
        open：以什么开头
        close：以什么结尾
--&gt;
&lt;delete id=&quot;deleteAll&quot;&gt;
    delete from category where id in
    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
        #{id}
    &lt;/foreach&gt;
&lt;/delete&gt;
</code></pre>
<h2 id="106-sql标签">10.6 sql标签</h2>
<pre><code class="language-xml">&lt;sql id=&quot;categoryColumn&quot;&gt;id,name,status,sort&lt;/sql&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;Category&quot;&gt;
    select &lt;include refid=&quot;categoryColumn&quot; /&gt; from category
&lt;/select&gt;
</code></pre>
<h1 id="11-缓存">11 缓存</h1>
<blockquote>
<p>mybatis会把查询到的数据进行缓存，这样相同的查询无需数据库请求即可完成。</p>
</blockquote>
<h2 id="111-一级缓存">11.1 一级缓存</h2>
<p>这是SqlSession层级的缓存默认开启，缓存是在一次sqlSession中存在的。相同SqlSession不同的mapper缓存也是共享的。</p>
<p><strong>一级缓存失效：</strong></p>
<ul>
<li>使用不同的SqlSession</li>
<li>两次查询条件不同</li>
<li>两次查询之间进行增删改</li>
<li>两次查询间手动清理缓存</li>
</ul>
<h2 id="112-二级缓存">11.2 二级缓存</h2>
<p>开启：</p>
<ol>
<li>确保cacheEnabled值为true（默认值），在全局设置中设置</li>
<li>映射文件中添加cache标签</li>
<li>二级缓存在SqlSession提交或关闭后生效</li>
<li>查询结果实体类必须实现序列化接口</li>
</ol>
<p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p>
<h2 id="113-二级缓存设置">11.3 二级缓存设置</h2>
<ul>
<li>在mapper配置文件中添加的cache标签可以设置一些属性</li>
<li>eviction属性：缓存回收策略
<ul>
<li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</li>
<li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
<li>默认的是 LRU</li>
</ul>
</li>
<li>flushInterval属性：刷新间隔，单位毫秒
<ul>
<li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li>
</ul>
</li>
<li>size属性：引用数目，正整数
<ul>
<li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li>
</ul>
</li>
<li>readOnly属性：只读，true/false
<ul>
<li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</li>
<li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</li>
</ul>
</li>
</ul>
<h2 id="114-mybatis缓存查询的顺序">11.4 MyBatis缓存查询的顺序</h2>
<ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用</li>
<li>如果二级缓存没有命中，再查询一级缓存</li>
<li>如果一级缓存也没有命中，则查询数据库</li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h1 id="12-分页插件">12. 分页插件</h1>
<ol>
<li>添加插件</li>
</ol>
<pre><code class="language-xml">&lt;!--分页插件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>核心配置文件配置</li>
</ol>
<pre><code class="language-xml">&lt;!--添加插件--&gt;
&lt;plugins&gt;
    &lt;!--分页插件--&gt;
    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;/&gt;
&lt;/plugins&gt;
</code></pre>
<ol start="3">
<li>3种简单实现</li>
</ol>
<pre><code class="language-java">@Test
public void testCategoryPage1() {
    PageHelper.startPage(1, 3);
    List&lt;Object&gt; list = sqlSession.selectList(&quot;categoryMapper.findAll&quot;);
    System.out.println(list);
}

@Test
public void testCategoryPage2() {
    Page&lt;Object&gt; page = PageHelper.startPage(1, 4);
    List&lt;Object&gt; list = sqlSession.selectList(&quot;categoryMapper.findAll&quot;);
    System.out.println(page);
    System.out.println(list);
}

@Test
public void testCategoryPage3() {
    PageHelper.startPage(1, 4);
    List&lt;Category&gt; list = sqlSession.selectList(&quot;categoryMapper.findAll&quot;);
    PageInfo&lt;Category&gt; page = new PageInfo&lt;&gt;(list, 5);
    System.out.println(page);
}
</code></pre>
<p>Page和PageInfo相关属性：</p>
<ul>
<li>list：分页之后的数据</li>
<li>pageNum：当前页的页码</li>
<li>pageSize：每页显示的条数</li>
<li>size：当前页显示的真实条数</li>
<li>total：总记录数</li>
<li>pages：总页数</li>
<li>prePage：上一页的页码</li>
<li>nextPage：下一页的页码</li>
<li>isFirstPage/isLastPage：是否为第一页/最后一页</li>
<li>hasPreviousPage/hasNextPage：是否存在上一页/下一页</li>
<li>navigatePages：导航分页的页码数</li>
<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li>
</ul>
<h1 id="13-注解开发">13. 注解开发</h1>
<blockquote>
<p>注解只适合简单的语句，并不适合复杂语句，使本就复杂的sql更复杂。使用注解开发不需要再创建Mapper配置文件。</p>
</blockquote>
<blockquote>
<p>主要的注解<code>@Select、@Insert、@Delete，@Update</code></p>
</blockquote>
<h2 id="131-简单实用">13.1 简单实用</h2>
<pre><code class="language-java">public interface MenuMapper {
  @Insert(&quot;insert into menu(`name`, `icon`, `link`, `parent`, `sort`, `status`) &quot; +
          &quot;value (#{name}, #{icon}, #{link}, #{parent}, #{sort}, #{status});&quot;)
  int insert(Menu menu);

  @Insert(&quot;delete from menu where id = #{id}&quot;)
  int delete(@Param(&quot;id&quot;) long id);

  @Update(&quot;update menu set name = #{name}, icon = #{icon}, link = #{link}, sort = #{sort} where id = #{id}&quot;)
  int update(Menu menu);

  @Select(&quot;select * from menu where id = #{id}&quot;)
  Menu select(@Param(&quot;id&quot;) long id);
}
</code></pre>
<h2 id="132-result-result-one-many">13.2 @Result、@Result、@One、@Many</h2>
<blockquote>
<p><code>@Result</code>是来替换<code>&lt;resultMap&gt;</code>，<code>@Result</code>替换标签<code>&lt;result&gt;</code>，<code>@One</code>替换标签<code>&lt;association&gt;</code>，<code>@Many</code>替换标签<code>&lt;collection&gt;</code></p>
</blockquote>
<p>@Result属性：</p>
<ul>
<li>column:数据库列名</li>
<li>property：属性名</li>
<li>one|many：<code>@One|@Many</code></li>
</ul>
<h3 id="1321-一对一">13.2.1 一对一</h3>
<pre><code class="language-java">public interface OrderMapper {

  @Results({
          @Result(property = &quot;id&quot;, column = &quot;id&quot;),
          @Result(property = &quot;orderTime&quot;, column = &quot;orderTime&quot;),
          @Result(property = &quot;total&quot;, column = &quot;total&quot;),
          @Result(property = &quot;user&quot;, column = &quot;uid&quot;, javaType = User.class, 
                  one = @One(select = &quot;UserMapper.findById&quot;))
  })
  @Select(&quot;select * from order&quot;)
  List&lt;Order&gt; findAll();
}

public interface UserMapper {
  
  @Select(&quot;select * from user where id = #{id}&quot;)
  List&lt;Order&gt; findById(Integer id);
}
</code></pre>
<h3 id="1322-一对多">13.2.2 一对多</h3>
<pre><code class="language-java">public interface UserMapper {

  @Results({
          @Result(property = &quot;id&quot;, column = &quot;id&quot;),
          @Result(property = &quot;name&quot;, column = &quot;name&quot;),
          @Result(property = &quot;sex&quot;, column = &quot;sex&quot;),
          @Result(property = &quot;order&quot;, column = &quot;id&quot;, javaType = List.class,
                  many = @Many(select = &quot;OrderMapper.findById&quot;))
  })
  @Select(&quot;select * from order&quot;)
  List&lt;User&gt; findAll();
}

public interface OrderMapper {

  @Select(&quot;select * from order where id = #{id}&quot;)
  List&lt;Order&gt; findById(Integer id);
}
</code></pre>
<h3 id="1323-多对多">13.2.3 多对多</h3>
<blockquote>
<p>和一对多很类似，只不过一对多返回的结果是单行数据，多对多返回的是集合。</p>
</blockquote>
<h2 id="133-注解配置属性">13.3 注解配置属性</h2>
<pre><code class="language-java">public interface UserDao {
    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)
    @Insert(&quot;INSERT INTO user (name, age, email, birthday) VALUES(#{name}, #{age}, #{email}, #{birthday})&quot;)
    int insert(User user);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程]]></title>
        <id>https://stackyu.github.io/post/java-duo-xian-cheng/</id>
        <link href="https://stackyu.github.io/post/java-duo-xian-cheng/">
        </link>
        <updated>2022-11-22T13:10:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="多线程">多线程</h1>
<h2 id="sleep和wait区别">sleep和wait区别</h2>
<p>sleep:暂停当前运行，短暂暂停不会释放锁。<br>
wait:暂停当前运行，暂停结束释放锁。</p>
<h2 id="sleep和yield的区别">sleep()和yield()的区别</h2>
<ol>
<li>sleep不考虑线程优先级，yield优先级越高机会越大。</li>
<li>sleep执行线程进入阻塞状态，yield执行线程进入就绪状态。</li>
<li>sleep()方法声明抛出 InterruptedException，而yield()方法没有声明任何异常。</li>
<li>yield让出了对CPU的占用权。</li>
</ol>
<h2 id="interrupt-interrupted和isinterrupted">interrupt、interrupted和isInterrupted</h2>
<p>interrupt：设置线程的中断状态为中断。（当前线程）</p>
<ul>
<li>标记中断的线程不会即可中断，需要用户监视线程的状态并做出处理。被标记中断状态线程会抛出异常interruptedException</li>
</ul>
<p>interrupted：静态方法，查看线程的中断状态并清除状态。</p>
<p>isInterrupted：返回线程的中断状态true和false。</p>
<h2 id="notify和notifyall">notify()和notifyAll()</h2>
<p>notify：随机唤醒一个阻塞线程，唤醒由虚拟机决定，参加锁的竞争。</p>
<p>notifyAll：唤醒全部阻塞方法，参加锁的竞争。</p>
<h2 id="并发编程三要素">并发编程三要素</h2>
<ul>
<li>原子性：原子性指的是一个或多个操作，要么全部执行并且不会被打断，要么全不执行。</li>
<li>可见性：当多线程操作共享数据时，一个线程修改数据，另一个线程可以查看修改后的数据。</li>
<li>有序性：程序的执行顺序按照代码的先后顺序执行。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>原子性：使用多线同步synchronize和锁Lock。</li>
<li>可见性：synchronize、volatile、lock。</li>
<li>顺序性：Happens-Before。</li>
</ul>
<h2 id="实现可见性的方法">实现可见性的方法</h2>
<p>synchronized或者lock：对即将修改的数据进行加锁，同一时刻只允许一个线程进行操作。</p>
<h2 id="多线程价值">多线程价值</h2>
<ol>
<li>发挥多核CPU：用多线程充分发挥CPU优势，同一时刻可以执行多件事。</li>
<li>防止阻塞：当在类似网络请求的网络请求中，服务方未能及时响应。这时就会造成线程等待，后续就要等待。多线程可以切换任务避免这种情况。</li>
<li>优化编程：将需求分开编程，再通过多线程分别执行。</li>
</ol>
<h2 id="创建线程方式">创建线程方式</h2>
<ul>
<li>继承Thread，实现run方法。</li>
<li>实现Runnable接口，实现run方法。</li>
<li>实现Callable接口，实现call方法。</li>
<li>匿名内部类。</li>
</ul>
<h2 id="创建方式对比">创建方式对比</h2>
<h3 id="runnable和callable">Runnable和Callable</h3>
<ul>
<li>Runnable和Callable是接口，不但可以实现此接口，还可以集成其他的父类，增加扩展性。</li>
<li>Callable重写的call方法，Runnable重写的run方法。</li>
<li>Callable执行完可以返回值（Future对象接收），也可以抛出异常。Runnable不可以。</li>
<li>获得当前线程需要使用Thread.currentThread()。</li>
</ul>
<ol start="2">
<li>Thread多线程<br>
获得当前线程使用this。</li>
</ol>
<h2 id="多线程状态">多线程状态</h2>
<ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 start() 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</li>
<li>BLOCKED ：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。<br>
<img src="../img/thread-status.png" alt="" loading="lazy"></li>
</ul>
<h2 id="线程池">线程池</h2>
<h3 id="是什么">是什么</h3>
<p>线程池就是创建多个线程，等到任务来的时候，使用多线程执行任务。完成后将线程放回线程池中等待下次调用。当频繁需要使用线程时可以使用线程池。</p>
<h3 id="创建方法">创建方法</h3>
<ol>
<li>使用ThreadPoolExecutor构造方法创建（推荐）（主要参数：核心数，最大数，超时时长，时间单位，任务队列）</li>
<li>Executor框架的工具类Executors来实现</li>
</ol>
<h3 id="优点">优点</h3>
<ol>
<li>重复使用线程，减少线程频繁创建线程的开销。</li>
<li>控制多线程数量，避免资源浪费和线程过多导致系统堵塞。</li>
<li>提供定时执行，定期执行等方法。</li>
</ol>
<h2 id="cyclicbarrier和countdownlatch">CyclicBarrier和CountDownLatch</h2>
<ul>
<li>CountDownLatch等待所有线程执行countDown方法后，当前线程才执行。</li>
<li>CyclicBarrier是等待所有线程进入wait方法后，所有线程在同时执行。</li>
<li>CountDownLatch计数器只能执行一次，CyclicBarrier可以通过reset方法重置计数。</li>
<li>CyclicBarrier还可以获得阻塞数，是否被中断。</li>
</ul>
<h2 id="volatile">volatile</h2>
<ol>
<li>保证变量的可见性</li>
<li>禁止指令重排序（单例模型）</li>
</ol>
<h1 id="synchronized">synchronized</h1>
<p>主要解决多线程之间访问资源的同步性。可以保证关键字修饰的方法和代码块同一时刻只能一个线程访问。早期版本synchronized比较重量级，1.6后优化较大。</p>
<h2 id="修饰方式-如何使用">修饰方式 | 如何使用</h2>
<ol>
<li>属性方法（对象锁）</li>
<li>静态方法（类锁）</li>
<li>代码块（对象/类锁）</li>
</ol>
<h2 id="synchronized底层实现原理">synchronized底层实现原理</h2>
<p>两者本质都是对monitor监视器锁的获取。</p>
<h3 id="修饰代码块">修饰代码块</h3>
<ol>
<li>synchronized底层是通过monitor指令来完成同步。</li>
<li>每个对象都会有一个monitor监视锁，每个被synchronized修饰过的代码当他的monitor被占用时就会处于锁定状态，并且尝试获取monitor的所有权。</li>
<li>尝试获得所有权的过程
<ol>
<li>判断monitor进入数是否为0，是的话当前线程进入monitor，并将进入数设置1，当前线程为monitor的所有者。</li>
<li>当前线程已获得所有权，当重新进入时就会进入数+1。</li>
<li>如果其他线程占用monitor，当前线程获得monitor需要阻塞等待，直到进入数为0，再尝试获取所有权。</li>
</ol>
</li>
</ol>
<h3 id="修饰方法">修饰方法</h3>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个<br>
同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h2 id="synchronized底层做了哪些优化imperfect">synchronized底层做了哪些优化（imperfect）</h2>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。<br>
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h2 id="synchronized锁膨胀升级过程">synchronized锁膨胀升级过程</h2>
<p><strong>锁只能升级不能降级，但是偏向锁可以改变成无锁状态。</strong></p>
<h3 id="相关锁介绍">相关锁介绍</h3>
<p>偏向锁：记录第一次获得锁的线程，类似可重入锁。</p>
<p>轻量级锁：类似自旋锁，竞争线程不挂起，进行无意义循环并尝试获得锁。</p>
<p>重量级锁：类似悲观锁，未获得锁线程被挂起，进入系统排队系统等待竞争。</p>
<h3 id="过程">过程</h3>
<figure data-type="image" tabindex="1"><img src="https://github.com/xiaoyu2017/JavaOffer/tree/master/img/synchronized%E5%8D%87%E7%BA%A7%E9%94%81.png" alt="" loading="lazy"></figure>
<h2 id="synchronized修饰构造方法">synchronized修饰构造方法</h2>
<p>构造方法不能使用synchronized关键字。构造方法本身就是同步方法，不需要同步修饰符。</p>
<h2 id="synchronized可重入锁">synchronized可重入锁</h2>
<p>当一个线程成功执行synchronized修饰的方法，此方法再调用其他synchronized修饰的方法就会出现问题。</p>
<p>设计方面：当前线程调用其他线程持有对象锁的方法时，就会发生阻塞。当调用当前线程持有的对象锁对象方法时，如果是可重入锁，则直接成功，否则失败阻塞。</p>
<p>synchronized是一个可重入锁。</p>
<h1 id="综合问题">综合问题</h1>
<h2 id="双重检验锁实现的单例模式">双重检验锁实现的单例模式</h2>
<pre><code class="language-java">public class Demo{
    private volatile static Demo demo;
    public static Demo getInstance() {
        if (demo == null) {
            synchronized (Demo.class){
                if (demo == null) {
                    demo = new Demo();
                }
            }
        }
    } 
}
</code></pre>
<p>细节：静态变量需要添加volatile，防止指令重排序。<br>
指令重排序：</p>
<ol>
<li>为demo分配空间</li>
<li>初始化demo</li>
<li>将demo指向分配的空间</li>
</ol>
<p>系统可能会安装1-3-2顺序执行，volatile可以防止出现这种现象。</p>
<h2 id="cas实现">CAS实现</h2>
<p>CAS是一种无锁算法，在不使用锁情况下实现多线程数据同步。</p>
<p>算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存位置V</li>
<li>需要进行比较的预期值A</li>
<li>需要写入的新值U</li>
</ul>
<p>CAS具体执行时，当且仅当预期值A符合内存地址V中存储的值时，就用新值U替换掉旧值，并写入到内存地址V中。否则自旋重写读取进行更新。</p>
<p>CAS产生的问题：</p>
<ol>
<li>
<p>ABA问题：CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么<br>
CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，<br>
这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
</li>
<li>
<p>循环时间长开销大：CAS算法需要不断地自旋来读取最新的内存值，长时间读取不到就会造成不必要的CPU开销。</p>
</li>
<li>
<p>只能保证一个共享变量的原子操作：jdk的AtomicReference来保证应用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作，解决了这一问题。</p>
</li>
</ol>
<h2 id="并发编程优缺点">并发编程优缺点</h2>
<p>优点：</p>
<ol>
<li>充分利用多核CPU的计算能力。</li>
<li>方便进行业务拆分，提升应用性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>并发不一定总是提高性能。</li>
<li>会导致内存泄漏、上下文切换、线程安全和死锁问题。</li>
</ol>
<h2 id="并发-并行和串行">并发、并行和串行</h2>
<ul>
<li>并发：多任务使用同一CPU按时间片段轮流执行。（并非同时运行，速度错觉）</li>
<li>并行：多CPU/核同时运行，多软件同时处理。（真同时运行）</li>
<li>串行：任务排队执行。</li>
</ul>
<h2 id="用户线程和守护线程">用户线程和守护线程</h2>
<p>用户线程：运行在前台，执行具体的任务。</p>
<p>守护线程：非守护线程的佣人，同用户线程生死。</p>
<h2 id="java多线程调度">Java多线程调度</h2>
<ul>
<li>分时调度</li>
<li>抢占调度（使用）</li>
</ul>
<h2 id="两个线程共享数据">两个线程共享数据</h2>
<p>两个线程共享变量，需要保证变量的线程安全。</p>
<h2 id="springmvc和servlet线程安全">SpringMVC和Servlet线程安全</h2>
<p>SpringMVC：不是线程安全<br>
Servlet：不是线程安全</p>
<h2 id="java中保证线程安全">Java中保证线程安全</h2>
<ol>
<li>使用原子类</li>
<li>使用synchronize自动锁</li>
<li>使用手动锁</li>
</ol>
<h2 id="线程优先级">线程优先级</h2>
<p>每个线程都有优先级，一般来说，优先级越高的线程执行优先级就越高。但这依赖线程调度的实现，最终实现依赖底层系统调度。优先级从1-10，越大优先级就越大。</p>
<h2 id="线程构造方法和静态块是被哪个线程调用">线程构造方法和静态块是被哪个线程调用</h2>
<p>是被new这个线程类的当前线程调用，run方法才是被创建线程调用。</p>
<h2 id="线程间通信">线程间通信</h2>
<p>实现：</p>
<ul>
<li>使用wait、notify、notifyAll</li>
<li>使用Condition进行线程通信</li>
</ul>
<p>原理：<br>
JMM，java内存模型，将多线程共享资源都存在一个主内存中。时时进行资源刷新。</p>
]]></content>
    </entry>
</feed>